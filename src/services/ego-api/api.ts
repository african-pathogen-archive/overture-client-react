/* tslint:disable */
/* eslint-disable */
/**
 * Ego Service API
 * Ego API Documentation
 *
 * The version of the OpenAPI document: 4.4.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ApiKeyResponse
 */
export interface ApiKeyResponse {
    /**
     * 
     * @type {string}
     * @memberof ApiKeyResponse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyResponse
     */
    'expiryDate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiKeyResponse
     */
    'isRevoked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyResponse
     */
    'issueDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyResponse
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiKeyResponse
     */
    'scope'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ApiKeyScopeResponse
 */
export interface ApiKeyScopeResponse {
    /**
     * 
     * @type {string}
     * @memberof ApiKeyScopeResponse
     */
    'client_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiKeyScopeResponse
     */
    'exp'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiKeyScopeResponse
     */
    'scope'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyScopeResponse
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface Application
 */
export interface Application {
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'clientId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'clientSecret'?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'errorRedirectUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'redirectUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'status'?: ApplicationStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'type'?: ApplicationTypeEnum;
}

export const ApplicationStatusEnum = {
    Approved: 'APPROVED',
    Disabled: 'DISABLED',
    Pending: 'PENDING',
    Rejected: 'REJECTED'
} as const;

export type ApplicationStatusEnum = typeof ApplicationStatusEnum[keyof typeof ApplicationStatusEnum];
export const ApplicationTypeEnum = {
    Client: 'CLIENT',
    Admin: 'ADMIN'
} as const;

export type ApplicationTypeEnum = typeof ApplicationTypeEnum[keyof typeof ApplicationTypeEnum];

/**
 * 
 * @export
 * @interface ApplicationPermission
 */
export interface ApplicationPermission {
    /**
     * 
     * @type {string}
     * @memberof ApplicationPermission
     */
    'accessLevel'?: ApplicationPermissionAccessLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof ApplicationPermission
     */
    'id'?: string;
    /**
     * 
     * @type {Application}
     * @memberof ApplicationPermission
     */
    'owner'?: Application;
    /**
     * 
     * @type {Policy}
     * @memberof ApplicationPermission
     */
    'policy'?: Policy;
}

export const ApplicationPermissionAccessLevelEnum = {
    Read: 'READ',
    Write: 'WRITE',
    Deny: 'DENY'
} as const;

export type ApplicationPermissionAccessLevelEnum = typeof ApplicationPermissionAccessLevelEnum[keyof typeof ApplicationPermissionAccessLevelEnum];

/**
 * 
 * @export
 * @interface CreateApplicationRequest
 */
export interface CreateApplicationRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationRequest
     */
    'clientId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationRequest
     */
    'clientSecret'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationRequest
     */
    'errorRedirectUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationRequest
     */
    'redirectUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationRequest
     */
    'status'?: CreateApplicationRequestStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationRequest
     */
    'type'?: CreateApplicationRequestTypeEnum;
}

export const CreateApplicationRequestStatusEnum = {
    Approved: 'APPROVED',
    Disabled: 'DISABLED',
    Pending: 'PENDING',
    Rejected: 'REJECTED'
} as const;

export type CreateApplicationRequestStatusEnum = typeof CreateApplicationRequestStatusEnum[keyof typeof CreateApplicationRequestStatusEnum];
export const CreateApplicationRequestTypeEnum = {
    Client: 'CLIENT',
    Admin: 'ADMIN'
} as const;

export type CreateApplicationRequestTypeEnum = typeof CreateApplicationRequestTypeEnum[keyof typeof CreateApplicationRequestTypeEnum];

/**
 * 
 * @export
 * @interface GenericResponse
 */
export interface GenericResponse {
    /**
     * 
     * @type {string}
     * @memberof GenericResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'status'?: GroupStatusEnum;
}

export const GroupStatusEnum = {
    Approved: 'APPROVED',
    Disabled: 'DISABLED',
    Pending: 'PENDING',
    Rejected: 'REJECTED'
} as const;

export type GroupStatusEnum = typeof GroupStatusEnum[keyof typeof GroupStatusEnum];

/**
 * 
 * @export
 * @interface GroupPermission
 */
export interface GroupPermission {
    /**
     * 
     * @type {string}
     * @memberof GroupPermission
     */
    'accessLevel'?: GroupPermissionAccessLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof GroupPermission
     */
    'id'?: string;
    /**
     * 
     * @type {Group}
     * @memberof GroupPermission
     */
    'owner'?: Group;
    /**
     * 
     * @type {Policy}
     * @memberof GroupPermission
     */
    'policy'?: Policy;
}

export const GroupPermissionAccessLevelEnum = {
    Read: 'READ',
    Write: 'WRITE',
    Deny: 'DENY'
} as const;

export type GroupPermissionAccessLevelEnum = typeof GroupPermissionAccessLevelEnum[keyof typeof GroupPermissionAccessLevelEnum];

/**
 * 
 * @export
 * @interface GroupRequest
 */
export interface GroupRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupRequest
     */
    'status'?: GroupRequestStatusEnum;
}

export const GroupRequestStatusEnum = {
    Approved: 'APPROVED',
    Disabled: 'DISABLED',
    Pending: 'PENDING',
    Rejected: 'REJECTED'
} as const;

export type GroupRequestStatusEnum = typeof GroupRequestStatusEnum[keyof typeof GroupRequestStatusEnum];

/**
 * 
 * @export
 * @interface Identifiable
 */
export interface Identifiable {
    /**
     * 
     * @type {object}
     * @memberof Identifiable
     */
    'id'?: object;
}
/**
 * 
 * @export
 * @interface MaskDTO
 */
export interface MaskDTO {
    /**
     * 
     * @type {string}
     * @memberof MaskDTO
     */
    'mask'?: MaskDTOMaskEnum;
}

export const MaskDTOMaskEnum = {
    Read: 'READ',
    Write: 'WRITE',
    Deny: 'DENY'
} as const;

export type MaskDTOMaskEnum = typeof MaskDTOMaskEnum[keyof typeof MaskDTOMaskEnum];

/**
 * 
 * @export
 * @interface OAuth2AccessToken
 */
export interface OAuth2AccessToken {
    /**
     * 
     * @type {object}
     * @memberof OAuth2AccessToken
     */
    'additionalInformation'?: object;
    /**
     * 
     * @type {string}
     * @memberof OAuth2AccessToken
     */
    'expiration'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OAuth2AccessToken
     */
    'expired'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof OAuth2AccessToken
     */
    'expiresIn'?: number;
    /**
     * 
     * @type {OAuth2RefreshToken}
     * @memberof OAuth2AccessToken
     */
    'refreshToken'?: OAuth2RefreshToken;
    /**
     * 
     * @type {Array<string>}
     * @memberof OAuth2AccessToken
     */
    'scope'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof OAuth2AccessToken
     */
    'tokenType'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2AccessToken
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface OAuth2RefreshToken
 */
export interface OAuth2RefreshToken {
    /**
     * 
     * @type {string}
     * @memberof OAuth2RefreshToken
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface PageDTOApiKeyResponse
 */
export interface PageDTOApiKeyResponse {
    /**
     * 
     * @type {number}
     * @memberof PageDTOApiKeyResponse
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDTOApiKeyResponse
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDTOApiKeyResponse
     */
    'offset'?: number;
    /**
     * 
     * @type {Array<ApiKeyResponse>}
     * @memberof PageDTOApiKeyResponse
     */
    'resultSet'?: Array<ApiKeyResponse>;
}
/**
 * 
 * @export
 * @interface PageDTOApplication
 */
export interface PageDTOApplication {
    /**
     * 
     * @type {number}
     * @memberof PageDTOApplication
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDTOApplication
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDTOApplication
     */
    'offset'?: number;
    /**
     * 
     * @type {Array<Application>}
     * @memberof PageDTOApplication
     */
    'resultSet'?: Array<Application>;
}
/**
 * 
 * @export
 * @interface PageDTOApplicationPermission
 */
export interface PageDTOApplicationPermission {
    /**
     * 
     * @type {number}
     * @memberof PageDTOApplicationPermission
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDTOApplicationPermission
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDTOApplicationPermission
     */
    'offset'?: number;
    /**
     * 
     * @type {Array<ApplicationPermission>}
     * @memberof PageDTOApplicationPermission
     */
    'resultSet'?: Array<ApplicationPermission>;
}
/**
 * 
 * @export
 * @interface PageDTOGroup
 */
export interface PageDTOGroup {
    /**
     * 
     * @type {number}
     * @memberof PageDTOGroup
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDTOGroup
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDTOGroup
     */
    'offset'?: number;
    /**
     * 
     * @type {Array<Group>}
     * @memberof PageDTOGroup
     */
    'resultSet'?: Array<Group>;
}
/**
 * 
 * @export
 * @interface PageDTOGroupPermission
 */
export interface PageDTOGroupPermission {
    /**
     * 
     * @type {number}
     * @memberof PageDTOGroupPermission
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDTOGroupPermission
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDTOGroupPermission
     */
    'offset'?: number;
    /**
     * 
     * @type {Array<GroupPermission>}
     * @memberof PageDTOGroupPermission
     */
    'resultSet'?: Array<GroupPermission>;
}
/**
 * 
 * @export
 * @interface PageDTOPolicy
 */
export interface PageDTOPolicy {
    /**
     * 
     * @type {number}
     * @memberof PageDTOPolicy
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDTOPolicy
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDTOPolicy
     */
    'offset'?: number;
    /**
     * 
     * @type {Array<Policy>}
     * @memberof PageDTOPolicy
     */
    'resultSet'?: Array<Policy>;
}
/**
 * 
 * @export
 * @interface PageDTOPolicyResponse
 */
export interface PageDTOPolicyResponse {
    /**
     * 
     * @type {number}
     * @memberof PageDTOPolicyResponse
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDTOPolicyResponse
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDTOPolicyResponse
     */
    'offset'?: number;
    /**
     * 
     * @type {Array<PolicyResponse>}
     * @memberof PageDTOPolicyResponse
     */
    'resultSet'?: Array<PolicyResponse>;
}
/**
 * 
 * @export
 * @interface PageDTOUser
 */
export interface PageDTOUser {
    /**
     * 
     * @type {number}
     * @memberof PageDTOUser
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDTOUser
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDTOUser
     */
    'offset'?: number;
    /**
     * 
     * @type {Array<User>}
     * @memberof PageDTOUser
     */
    'resultSet'?: Array<User>;
}
/**
 * 
 * @export
 * @interface PageDTOUserPermission
 */
export interface PageDTOUserPermission {
    /**
     * 
     * @type {number}
     * @memberof PageDTOUserPermission
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDTOUserPermission
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDTOUserPermission
     */
    'offset'?: number;
    /**
     * 
     * @type {Array<UserPermission>}
     * @memberof PageDTOUserPermission
     */
    'resultSet'?: Array<UserPermission>;
}
/**
 * 
 * @export
 * @interface PermissionRequest
 */
export interface PermissionRequest {
    /**
     * 
     * @type {string}
     * @memberof PermissionRequest
     */
    'mask'?: PermissionRequestMaskEnum;
    /**
     * 
     * @type {string}
     * @memberof PermissionRequest
     */
    'policyId'?: string;
}

export const PermissionRequestMaskEnum = {
    Read: 'READ',
    Write: 'WRITE',
    Deny: 'DENY'
} as const;

export type PermissionRequestMaskEnum = typeof PermissionRequestMaskEnum[keyof typeof PermissionRequestMaskEnum];

/**
 * 
 * @export
 * @interface Policy
 */
export interface Policy {
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface PolicyRequest
 */
export interface PolicyRequest {
    /**
     * 
     * @type {string}
     * @memberof PolicyRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface PolicyResponse
 */
export interface PolicyResponse {
    /**
     * 
     * @type {string}
     * @memberof PolicyResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PolicyResponse
     */
    'mask'?: PolicyResponseMaskEnum;
    /**
     * 
     * @type {string}
     * @memberof PolicyResponse
     */
    'name'?: string;
}

export const PolicyResponseMaskEnum = {
    Read: 'READ',
    Write: 'WRITE',
    Deny: 'DENY'
} as const;

export type PolicyResponseMaskEnum = typeof PolicyResponseMaskEnum[keyof typeof PolicyResponseMaskEnum];

/**
 * 
 * @export
 * @interface ResolvedPermissionResponse
 */
export interface ResolvedPermissionResponse {
    /**
     * 
     * @type {string}
     * @memberof ResolvedPermissionResponse
     */
    'accessLevel'?: ResolvedPermissionResponseAccessLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof ResolvedPermissionResponse
     */
    'id'?: string;
    /**
     * 
     * @type {Identifiable}
     * @memberof ResolvedPermissionResponse
     */
    'owner'?: Identifiable;
    /**
     * 
     * @type {string}
     * @memberof ResolvedPermissionResponse
     */
    'ownerType'?: string;
    /**
     * 
     * @type {Policy}
     * @memberof ResolvedPermissionResponse
     */
    'policy'?: Policy;
}

export const ResolvedPermissionResponseAccessLevelEnum = {
    Read: 'READ',
    Write: 'WRITE',
    Deny: 'DENY'
} as const;

export type ResolvedPermissionResponseAccessLevelEnum = typeof ResolvedPermissionResponseAccessLevelEnum[keyof typeof ResolvedPermissionResponseAccessLevelEnum];

/**
 * 
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'accessToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof TokenResponse
     */
    'exp'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof TokenResponse
     */
    'scope'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TransactionalDeleteRequest
 */
export interface TransactionalDeleteRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof TransactionalDeleteRequest
     */
    'groupNames'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TransactionalDeleteRequest
     */
    'policyNames'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TransactionalGroupPermissionRequest
 */
export interface TransactionalGroupPermissionRequest {
    /**
     * 
     * @type {string}
     * @memberof TransactionalGroupPermissionRequest
     */
    'groupName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionalGroupPermissionRequest
     */
    'mask'?: TransactionalGroupPermissionRequestMaskEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactionalGroupPermissionRequest
     */
    'policyName'?: string;
}

export const TransactionalGroupPermissionRequestMaskEnum = {
    Read: 'READ',
    Write: 'WRITE',
    Deny: 'DENY'
} as const;

export type TransactionalGroupPermissionRequestMaskEnum = typeof TransactionalGroupPermissionRequestMaskEnum[keyof typeof TransactionalGroupPermissionRequestMaskEnum];

/**
 * 
 * @export
 * @interface UpdateApplicationRequest
 */
export interface UpdateApplicationRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationRequest
     */
    'clientId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationRequest
     */
    'clientSecret'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationRequest
     */
    'errorRedirectUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationRequest
     */
    'redirectUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationRequest
     */
    'status'?: UpdateApplicationRequestStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationRequest
     */
    'type'?: UpdateApplicationRequestTypeEnum;
}

export const UpdateApplicationRequestStatusEnum = {
    Approved: 'APPROVED',
    Disabled: 'DISABLED',
    Pending: 'PENDING',
    Rejected: 'REJECTED'
} as const;

export type UpdateApplicationRequestStatusEnum = typeof UpdateApplicationRequestStatusEnum[keyof typeof UpdateApplicationRequestStatusEnum];
export const UpdateApplicationRequestTypeEnum = {
    Client: 'CLIENT',
    Admin: 'ADMIN'
} as const;

export type UpdateApplicationRequestTypeEnum = typeof UpdateApplicationRequestTypeEnum[keyof typeof UpdateApplicationRequestTypeEnum];

/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'preferredLanguage'?: UpdateUserRequestPreferredLanguageEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'status'?: UpdateUserRequestStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'type'?: UpdateUserRequestTypeEnum;
}

export const UpdateUserRequestPreferredLanguageEnum = {
    English: 'ENGLISH',
    French: 'FRENCH',
    Spanish: 'SPANISH'
} as const;

export type UpdateUserRequestPreferredLanguageEnum = typeof UpdateUserRequestPreferredLanguageEnum[keyof typeof UpdateUserRequestPreferredLanguageEnum];
export const UpdateUserRequestStatusEnum = {
    Approved: 'APPROVED',
    Disabled: 'DISABLED',
    Pending: 'PENDING',
    Rejected: 'REJECTED'
} as const;

export type UpdateUserRequestStatusEnum = typeof UpdateUserRequestStatusEnum[keyof typeof UpdateUserRequestStatusEnum];
export const UpdateUserRequestTypeEnum = {
    User: 'USER',
    Admin: 'ADMIN'
} as const;

export type UpdateUserRequestTypeEnum = typeof UpdateUserRequestTypeEnum[keyof typeof UpdateUserRequestTypeEnum];

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'groups'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastLogin'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'preferredLanguage'?: UserPreferredLanguageEnum;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'providerSubjectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'providerType'?: UserProviderTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'status'?: UserStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'type'?: UserTypeEnum;
}

export const UserPreferredLanguageEnum = {
    English: 'ENGLISH',
    French: 'FRENCH',
    Spanish: 'SPANISH'
} as const;

export type UserPreferredLanguageEnum = typeof UserPreferredLanguageEnum[keyof typeof UserPreferredLanguageEnum];
export const UserProviderTypeEnum = {
    Google: 'GOOGLE',
    Facebook: 'FACEBOOK',
    Linkedin: 'LINKEDIN',
    Github: 'GITHUB',
    Orcid: 'ORCID',
    Keycloak: 'KEYCLOAK'
} as const;

export type UserProviderTypeEnum = typeof UserProviderTypeEnum[keyof typeof UserProviderTypeEnum];
export const UserStatusEnum = {
    Approved: 'APPROVED',
    Disabled: 'DISABLED',
    Pending: 'PENDING',
    Rejected: 'REJECTED'
} as const;

export type UserStatusEnum = typeof UserStatusEnum[keyof typeof UserStatusEnum];
export const UserTypeEnum = {
    User: 'USER',
    Admin: 'ADMIN'
} as const;

export type UserTypeEnum = typeof UserTypeEnum[keyof typeof UserTypeEnum];

/**
 * 
 * @export
 * @interface UserPermission
 */
export interface UserPermission {
    /**
     * 
     * @type {string}
     * @memberof UserPermission
     */
    'accessLevel'?: UserPermissionAccessLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof UserPermission
     */
    'id'?: string;
    /**
     * 
     * @type {User}
     * @memberof UserPermission
     */
    'owner'?: User;
    /**
     * 
     * @type {Policy}
     * @memberof UserPermission
     */
    'policy'?: Policy;
}

export const UserPermissionAccessLevelEnum = {
    Read: 'READ',
    Write: 'WRITE',
    Deny: 'DENY'
} as const;

export type UserPermissionAccessLevelEnum = typeof UserPermissionAccessLevelEnum[keyof typeof UserPermissionAccessLevelEnum];

/**
 * 
 * @export
 * @interface UserScopesResponse
 */
export interface UserScopesResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof UserScopesResponse
     */
    'scopes'?: Array<string>;
}

/**
 * ApiKeysApi - axios parameter creator
 * @export
 */
export const ApiKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary checkApiKey
         * @param {string} authorization Authorization
         * @param {string} apiKey apiKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkApiKeyUsingPOST: async (authorization: string, apiKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('checkApiKeyUsingPOST', 'authorization', authorization)
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('checkApiKeyUsingPOST', 'apiKey', apiKey)
            const localVarPath = `/o/check_api_key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary checkToken
         * @param {string} authorization Authorization
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        checkTokenUsingPOST: async (authorization: string, token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('checkTokenUsingPOST', 'authorization', authorization)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('checkTokenUsingPOST', 'token', token)
            const localVarPath = `/o/check_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserScope
         * @param {string} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserScopeUsingGET: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserScopeUsingGET', 'userId', userId)
            const localVarPath = `/o/scopes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary issueApiKey
         * @param {Array<string>} scopes scopes
         * @param {string} userId user_id
         * @param {string} [description] description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueApiKeyUsingPOST: async (scopes: Array<string>, userId: string, description?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scopes' is not null or undefined
            assertParamExists('issueApiKeyUsingPOST', 'scopes', scopes)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('issueApiKeyUsingPOST', 'userId', userId)
            const localVarPath = `/o/api_key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (scopes) {
                localVarQueryParameter['scopes'] = scopes;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary issueToken
         * @param {Array<string>} scopes scopes
         * @param {string} userId user_id
         * @param {string} [description] description
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        issueTokenUsingPOST: async (scopes: Array<string>, userId: string, description?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scopes' is not null or undefined
            assertParamExists('issueTokenUsingPOST', 'scopes', scopes)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('issueTokenUsingPOST', 'userId', userId)
            const localVarPath = `/o/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (scopes) {
                localVarQueryParameter['scopes'] = scopes;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listApiKeys
         * @param {string} userId user_id
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] Query string compares to ApiKey\&#39;s Name fields.
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysUsingGET: async (userId: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listApiKeysUsingGET', 'userId', userId)
            const localVarPath = `/o/api_key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listTokens
         * @param {string} userId user_id
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listTokensUsingGET: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listTokensUsingGET', 'userId', userId)
            const localVarPath = `/o/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary revokeApiKey
         * @param {string} apiKey apiKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeApiKeyUsingDELETE: async (apiKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('revokeApiKeyUsingDELETE', 'apiKey', apiKey)
            const localVarPath = `/o/api_key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary revokeToken
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        revokeTokenUsingDELETE: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('revokeTokenUsingDELETE', 'token', token)
            const localVarPath = `/o/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiKeysApi - functional programming interface
 * @export
 */
export const ApiKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary checkApiKey
         * @param {string} authorization Authorization
         * @param {string} apiKey apiKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkApiKeyUsingPOST(authorization: string, apiKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkApiKeyUsingPOST(authorization, apiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary checkToken
         * @param {string} authorization Authorization
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async checkTokenUsingPOST(authorization: string, token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkTokenUsingPOST(authorization, token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getUserScope
         * @param {string} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserScopeUsingGET(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserScopesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserScopeUsingGET(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary issueApiKey
         * @param {Array<string>} scopes scopes
         * @param {string} userId user_id
         * @param {string} [description] description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueApiKeyUsingPOST(scopes: Array<string>, userId: string, description?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueApiKeyUsingPOST(scopes, userId, description, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary issueToken
         * @param {Array<string>} scopes scopes
         * @param {string} userId user_id
         * @param {string} [description] description
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async issueTokenUsingPOST(scopes: Array<string>, userId: string, description?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueTokenUsingPOST(scopes, userId, description, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary listApiKeys
         * @param {string} userId user_id
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] Query string compares to ApiKey\&#39;s Name fields.
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApiKeysUsingGET(userId: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDTOApiKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApiKeysUsingGET(userId, limit, offset, query, sort, sortOrder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary listTokens
         * @param {string} userId user_id
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async listTokensUsingGET(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TokenResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTokensUsingGET(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary revokeApiKey
         * @param {string} apiKey apiKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeApiKeyUsingDELETE(apiKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeApiKeyUsingDELETE(apiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary revokeToken
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async revokeTokenUsingDELETE(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeTokenUsingDELETE(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApiKeysApi - factory interface
 * @export
 */
export const ApiKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiKeysApiFp(configuration)
    return {
        /**
         * 
         * @summary checkApiKey
         * @param {string} authorization Authorization
         * @param {string} apiKey apiKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkApiKeyUsingPOST(authorization: string, apiKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.checkApiKeyUsingPOST(authorization, apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary checkToken
         * @param {string} authorization Authorization
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        checkTokenUsingPOST(authorization: string, token: string, options?: any): AxiosPromise<void> {
            return localVarFp.checkTokenUsingPOST(authorization, token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getUserScope
         * @param {string} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserScopeUsingGET(userId: string, options?: any): AxiosPromise<UserScopesResponse> {
            return localVarFp.getUserScopeUsingGET(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary issueApiKey
         * @param {Array<string>} scopes scopes
         * @param {string} userId user_id
         * @param {string} [description] description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueApiKeyUsingPOST(scopes: Array<string>, userId: string, description?: string, options?: any): AxiosPromise<ApiKeyResponse> {
            return localVarFp.issueApiKeyUsingPOST(scopes, userId, description, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary issueToken
         * @param {Array<string>} scopes scopes
         * @param {string} userId user_id
         * @param {string} [description] description
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        issueTokenUsingPOST(scopes: Array<string>, userId: string, description?: string, options?: any): AxiosPromise<TokenResponse> {
            return localVarFp.issueTokenUsingPOST(scopes, userId, description, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary listApiKeys
         * @param {string} userId user_id
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] Query string compares to ApiKey\&#39;s Name fields.
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysUsingGET(userId: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: any): AxiosPromise<PageDTOApiKeyResponse> {
            return localVarFp.listApiKeysUsingGET(userId, limit, offset, query, sort, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary listTokens
         * @param {string} userId user_id
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listTokensUsingGET(userId: string, options?: any): AxiosPromise<Array<TokenResponse>> {
            return localVarFp.listTokensUsingGET(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary revokeApiKey
         * @param {string} apiKey apiKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeApiKeyUsingDELETE(apiKey: string, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.revokeApiKeyUsingDELETE(apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary revokeToken
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        revokeTokenUsingDELETE(token: string, options?: any): AxiosPromise<string> {
            return localVarFp.revokeTokenUsingDELETE(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiKeysApi - object-oriented interface
 * @export
 * @class ApiKeysApi
 * @extends {BaseAPI}
 */
export class ApiKeysApi extends BaseAPI {
    /**
     * 
     * @summary checkApiKey
     * @param {string} authorization Authorization
     * @param {string} apiKey apiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public checkApiKeyUsingPOST(authorization: string, apiKey: string, options?: AxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).checkApiKeyUsingPOST(authorization, apiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary checkToken
     * @param {string} authorization Authorization
     * @param {string} token token
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public checkTokenUsingPOST(authorization: string, token: string, options?: AxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).checkTokenUsingPOST(authorization, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getUserScope
     * @param {string} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public getUserScopeUsingGET(userId: string, options?: AxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).getUserScopeUsingGET(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary issueApiKey
     * @param {Array<string>} scopes scopes
     * @param {string} userId user_id
     * @param {string} [description] description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public issueApiKeyUsingPOST(scopes: Array<string>, userId: string, description?: string, options?: AxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).issueApiKeyUsingPOST(scopes, userId, description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary issueToken
     * @param {Array<string>} scopes scopes
     * @param {string} userId user_id
     * @param {string} [description] description
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public issueTokenUsingPOST(scopes: Array<string>, userId: string, description?: string, options?: AxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).issueTokenUsingPOST(scopes, userId, description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary listApiKeys
     * @param {string} userId user_id
     * @param {string} [limit] Number of results to retrieve
     * @param {string} [offset] Index of first result to retrieve
     * @param {string} [query] Query string compares to ApiKey\&#39;s Name fields.
     * @param {string} [sort] Field to sort on
     * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public listApiKeysUsingGET(userId: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).listApiKeysUsingGET(userId, limit, offset, query, sort, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary listTokens
     * @param {string} userId user_id
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public listTokensUsingGET(userId: string, options?: AxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).listTokensUsingGET(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary revokeApiKey
     * @param {string} apiKey apiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public revokeApiKeyUsingDELETE(apiKey: string, options?: AxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).revokeApiKeyUsingDELETE(apiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary revokeToken
     * @param {string} token token
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public revokeTokenUsingDELETE(token: string, options?: AxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).revokeTokenUsingDELETE(token, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationsApi - axios parameter creator
 * @export
 */
export const ApplicationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addPermissions
         * @param {string} id id
         * @param {Array<PermissionRequest>} permissions permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPermissionsUsingPOST: async (id: string, permissions: Array<PermissionRequest>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addPermissionsUsingPOST', 'id', id)
            // verify required parameter 'permissions' is not null or undefined
            assertParamExists('addPermissionsUsingPOST', 'permissions', permissions)
            const localVarPath = `/applications/{id}/permissions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(permissions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createApplication
         * @param {CreateApplicationRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationUsingPOST: async (request: CreateApplicationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createApplicationUsingPOST', 'request', request)
            const localVarPath = `/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteApplication
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationUsingDELETE: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteApplicationUsingDELETE', 'id', id)
            const localVarPath = `/applications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deletePermissions
         * @param {string} id id
         * @param {string} permissionIds permissionIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermissionsUsingDELETE: async (id: string, permissionIds: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePermissionsUsingDELETE', 'id', id)
            // verify required parameter 'permissionIds' is not null or undefined
            assertParamExists('deletePermissionsUsingDELETE', 'permissionIds', permissionIds)
            const localVarPath = `/applications/{id}/permissions/{permissionIds}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"permissionIds"}}`, encodeURIComponent(String(permissionIds)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getApplication
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsingGET: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getApplicationUsingGET', 'id', id)
            const localVarPath = `/applications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getGroupsForApplication
         * @param {string} id id
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] query
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsForApplicationUsingGET: async (id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGroupsForApplicationUsingGET', 'id', id)
            const localVarPath = `/applications/{id}/groups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getPermissionsForApplication
         * @param {string} id id
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionsForApplicationUsingGET: async (id: string, limit?: string, offset?: string, sort?: string, sortOrder?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPermissionsForApplicationUsingGET', 'id', id)
            const localVarPath = `/applications/{id}/permissions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getResolvedPermissions
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResolvedPermissionsUsingGET: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getResolvedPermissionsUsingGET', 'id', id)
            const localVarPath = `/applications/{id}/groups/permissions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUsersForApplication
         * @param {string} id id
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] query
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersForApplicationUsingGET: async (id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersForApplicationUsingGET', 'id', id)
            const localVarPath = `/applications/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listApplications
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] query
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationsUsingGET: async (limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateApplication
         * @param {string} id id
         * @param {UpdateApplicationRequest} updateRequest updateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationUsingPUT: async (id: string, updateRequest: UpdateApplicationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateApplicationUsingPUT', 'id', id)
            // verify required parameter 'updateRequest' is not null or undefined
            assertParamExists('updateApplicationUsingPUT', 'updateRequest', updateRequest)
            const localVarPath = `/applications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationsApi - functional programming interface
 * @export
 */
export const ApplicationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary addPermissions
         * @param {string} id id
         * @param {Array<PermissionRequest>} permissions permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPermissionsUsingPOST(id: string, permissions: Array<PermissionRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPermissionsUsingPOST(id, permissions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary createApplication
         * @param {CreateApplicationRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationUsingPOST(request: CreateApplicationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deleteApplication
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationUsingDELETE(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationUsingDELETE(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deletePermissions
         * @param {string} id id
         * @param {string} permissionIds permissionIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePermissionsUsingDELETE(id: string, permissionIds: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePermissionsUsingDELETE(id, permissionIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getApplication
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationUsingGET(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationUsingGET(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getGroupsForApplication
         * @param {string} id id
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] query
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupsForApplicationUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDTOGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupsForApplicationUsingGET(id, limit, offset, query, sort, sortOrder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getPermissionsForApplication
         * @param {string} id id
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermissionsForApplicationUsingGET(id: string, limit?: string, offset?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDTOApplicationPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermissionsForApplicationUsingGET(id, limit, offset, sort, sortOrder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getResolvedPermissions
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResolvedPermissionsUsingGET(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResolvedPermissionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResolvedPermissionsUsingGET(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getUsersForApplication
         * @param {string} id id
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] query
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersForApplicationUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDTOUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersForApplicationUsingGET(id, limit, offset, query, sort, sortOrder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary listApplications
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] query
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationsUsingGET(limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDTOApplication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationsUsingGET(limit, offset, query, sort, sortOrder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updateApplication
         * @param {string} id id
         * @param {UpdateApplicationRequest} updateRequest updateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApplicationUsingPUT(id: string, updateRequest: UpdateApplicationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplicationUsingPUT(id, updateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationsApi - factory interface
 * @export
 */
export const ApplicationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationsApiFp(configuration)
    return {
        /**
         * 
         * @summary addPermissions
         * @param {string} id id
         * @param {Array<PermissionRequest>} permissions permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPermissionsUsingPOST(id: string, permissions: Array<PermissionRequest>, options?: any): AxiosPromise<Application> {
            return localVarFp.addPermissionsUsingPOST(id, permissions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary createApplication
         * @param {CreateApplicationRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationUsingPOST(request: CreateApplicationRequest, options?: any): AxiosPromise<Application> {
            return localVarFp.createApplicationUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteApplication
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationUsingDELETE(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplicationUsingDELETE(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deletePermissions
         * @param {string} id id
         * @param {string} permissionIds permissionIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermissionsUsingDELETE(id: string, permissionIds: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePermissionsUsingDELETE(id, permissionIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getApplication
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsingGET(id: string, options?: any): AxiosPromise<Application> {
            return localVarFp.getApplicationUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getGroupsForApplication
         * @param {string} id id
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] query
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsForApplicationUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: any): AxiosPromise<PageDTOGroup> {
            return localVarFp.getGroupsForApplicationUsingGET(id, limit, offset, query, sort, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getPermissionsForApplication
         * @param {string} id id
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionsForApplicationUsingGET(id: string, limit?: string, offset?: string, sort?: string, sortOrder?: string, options?: any): AxiosPromise<PageDTOApplicationPermission> {
            return localVarFp.getPermissionsForApplicationUsingGET(id, limit, offset, sort, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getResolvedPermissions
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResolvedPermissionsUsingGET(id: string, options?: any): AxiosPromise<Array<ResolvedPermissionResponse>> {
            return localVarFp.getResolvedPermissionsUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getUsersForApplication
         * @param {string} id id
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] query
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersForApplicationUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: any): AxiosPromise<PageDTOUser> {
            return localVarFp.getUsersForApplicationUsingGET(id, limit, offset, query, sort, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary listApplications
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] query
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationsUsingGET(limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: any): AxiosPromise<PageDTOApplication> {
            return localVarFp.listApplicationsUsingGET(limit, offset, query, sort, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateApplication
         * @param {string} id id
         * @param {UpdateApplicationRequest} updateRequest updateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationUsingPUT(id: string, updateRequest: UpdateApplicationRequest, options?: any): AxiosPromise<Application> {
            return localVarFp.updateApplicationUsingPUT(id, updateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationsApi - object-oriented interface
 * @export
 * @class ApplicationsApi
 * @extends {BaseAPI}
 */
export class ApplicationsApi extends BaseAPI {
    /**
     * 
     * @summary addPermissions
     * @param {string} id id
     * @param {Array<PermissionRequest>} permissions permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public addPermissionsUsingPOST(id: string, permissions: Array<PermissionRequest>, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).addPermissionsUsingPOST(id, permissions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary createApplication
     * @param {CreateApplicationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public createApplicationUsingPOST(request: CreateApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).createApplicationUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteApplication
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public deleteApplicationUsingDELETE(id: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).deleteApplicationUsingDELETE(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deletePermissions
     * @param {string} id id
     * @param {string} permissionIds permissionIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public deletePermissionsUsingDELETE(id: string, permissionIds: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).deletePermissionsUsingDELETE(id, permissionIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getApplication
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getApplicationUsingGET(id: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getApplicationUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getGroupsForApplication
     * @param {string} id id
     * @param {string} [limit] Number of results to retrieve
     * @param {string} [offset] Index of first result to retrieve
     * @param {string} [query] query
     * @param {string} [sort] Field to sort on
     * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getGroupsForApplicationUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getGroupsForApplicationUsingGET(id, limit, offset, query, sort, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getPermissionsForApplication
     * @param {string} id id
     * @param {string} [limit] Number of results to retrieve
     * @param {string} [offset] Index of first result to retrieve
     * @param {string} [sort] Field to sort on
     * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getPermissionsForApplicationUsingGET(id: string, limit?: string, offset?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getPermissionsForApplicationUsingGET(id, limit, offset, sort, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getResolvedPermissions
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getResolvedPermissionsUsingGET(id: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getResolvedPermissionsUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getUsersForApplication
     * @param {string} id id
     * @param {string} [limit] Number of results to retrieve
     * @param {string} [offset] Index of first result to retrieve
     * @param {string} [query] query
     * @param {string} [sort] Field to sort on
     * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getUsersForApplicationUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getUsersForApplicationUsingGET(id, limit, offset, query, sort, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary listApplications
     * @param {string} [limit] Number of results to retrieve
     * @param {string} [offset] Index of first result to retrieve
     * @param {string} [query] query
     * @param {string} [sort] Field to sort on
     * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public listApplicationsUsingGET(limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).listApplicationsUsingGET(limit, offset, query, sort, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateApplication
     * @param {string} id id
     * @param {UpdateApplicationRequest} updateRequest updateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public updateApplicationUsingPUT(id: string, updateRequest: UpdateApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).updateApplicationUsingPUT(id, updateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteRefreshToken
         * @param {string} [refreshId] refreshId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRefreshTokenUsingDELETE: async (refreshId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary exchangeFacebookTokenForAuth
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangeFacebookTokenForAuthUsingGET: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('exchangeFacebookTokenForAuthUsingGET', 'token', token)
            const localVarPath = `/oauth/facebook/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (token !== undefined && token !== null) {
                localVarHeaderParameter['token'] = String(token);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary exchangeGoogleTokenForAuth
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangeGoogleTokenForAuthUsingGET: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('exchangeGoogleTokenForAuthUsingGET', 'token', token)
            const localVarPath = `/oauth/google/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (token !== undefined && token !== null) {
                localVarHeaderParameter['token'] = String(token);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getPublicKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeyUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth/token/public_key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary postAccessToken
         * @param {string} clientId 
         * @param {string} clientSecret 
         * @param {string} grantType 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccessTokenUsingPOST: async (clientId: string, clientSecret: string, grantType: string, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('postAccessTokenUsingPOST', 'clientId', clientId)
            // verify required parameter 'clientSecret' is not null or undefined
            assertParamExists('postAccessTokenUsingPOST', 'clientSecret', clientSecret)
            // verify required parameter 'grantType' is not null or undefined
            assertParamExists('postAccessTokenUsingPOST', 'grantType', grantType)
            const localVarPath = `/oauth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (clientId !== undefined) {
                localVarQueryParameter['client_id'] = clientId;
            }

            if (clientSecret !== undefined) {
                localVarQueryParameter['client_secret'] = clientSecret;
            }

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary refreshEgoToken
         * @param {string} [refreshId] refreshId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshEgoTokenUsingPOST: async (refreshId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateEgoToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEgoTokenUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth/update-ego-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateEgoToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEgoTokenUsingPOST: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth/update-ego-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary user
         * @param {boolean} [oAuth2RequestApproved] 
         * @param {string} [oAuth2RequestAuthorities0Authority] 
         * @param {string} [oAuth2RequestGrantType] 
         * @param {string} [oAuth2RequestRedirectUri] 
         * @param {boolean} [oAuth2RequestRefresh] 
         * @param {string} [oAuth2RequestRefreshTokenRequestGrantType] 
         * @param {Array<string>} [oAuth2RequestResourceIds] 
         * @param {Array<string>} [oAuth2RequestResponseTypes] 
         * @param {boolean} [authenticated] 
         * @param {string} [authorities0Authority] 
         * @param {boolean} [clientOnly] 
         * @param {object} [credentials] 
         * @param {object} [details] 
         * @param {string} [name] 
         * @param {object} [principal] 
         * @param {boolean} [userAuthenticationAuthenticated] 
         * @param {string} [userAuthenticationAuthorities0Authority] 
         * @param {object} [userAuthenticationCredentials] 
         * @param {object} [userAuthenticationDetails] 
         * @param {object} [userAuthenticationPrincipal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUsingGET: async (oAuth2RequestApproved?: boolean, oAuth2RequestAuthorities0Authority?: string, oAuth2RequestGrantType?: string, oAuth2RequestRedirectUri?: string, oAuth2RequestRefresh?: boolean, oAuth2RequestRefreshTokenRequestGrantType?: string, oAuth2RequestResourceIds?: Array<string>, oAuth2RequestResponseTypes?: Array<string>, authenticated?: boolean, authorities0Authority?: string, clientOnly?: boolean, credentials?: object, details?: object, name?: string, principal?: object, userAuthenticationAuthenticated?: boolean, userAuthenticationAuthorities0Authority?: string, userAuthenticationCredentials?: object, userAuthenticationDetails?: object, userAuthenticationPrincipal?: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth/ego-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (oAuth2RequestApproved !== undefined) {
                localVarQueryParameter['OAuth2Request.approved'] = oAuth2RequestApproved;
            }

            if (oAuth2RequestAuthorities0Authority !== undefined) {
                localVarQueryParameter['OAuth2Request.authorities[0].authority'] = oAuth2RequestAuthorities0Authority;
            }

            if (oAuth2RequestGrantType !== undefined) {
                localVarQueryParameter['OAuth2Request.grantType'] = oAuth2RequestGrantType;
            }

            if (oAuth2RequestRedirectUri !== undefined) {
                localVarQueryParameter['OAuth2Request.redirectUri'] = oAuth2RequestRedirectUri;
            }

            if (oAuth2RequestRefresh !== undefined) {
                localVarQueryParameter['OAuth2Request.refresh'] = oAuth2RequestRefresh;
            }

            if (oAuth2RequestRefreshTokenRequestGrantType !== undefined) {
                localVarQueryParameter['OAuth2Request.refreshTokenRequest.grantType'] = oAuth2RequestRefreshTokenRequestGrantType;
            }

            if (oAuth2RequestResourceIds) {
                localVarQueryParameter['OAuth2Request.resourceIds'] = oAuth2RequestResourceIds;
            }

            if (oAuth2RequestResponseTypes) {
                localVarQueryParameter['OAuth2Request.responseTypes'] = oAuth2RequestResponseTypes;
            }

            if (authenticated !== undefined) {
                localVarQueryParameter['authenticated'] = authenticated;
            }

            if (authorities0Authority !== undefined) {
                localVarQueryParameter['authorities[0].authority'] = authorities0Authority;
            }

            if (clientOnly !== undefined) {
                localVarQueryParameter['clientOnly'] = clientOnly;
            }

            if (credentials !== undefined) {
                localVarQueryParameter['credentials'] = credentials;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (principal !== undefined) {
                localVarQueryParameter['principal'] = principal;
            }

            if (userAuthenticationAuthenticated !== undefined) {
                localVarQueryParameter['userAuthentication.authenticated'] = userAuthenticationAuthenticated;
            }

            if (userAuthenticationAuthorities0Authority !== undefined) {
                localVarQueryParameter['userAuthentication.authorities[0].authority'] = userAuthenticationAuthorities0Authority;
            }

            if (userAuthenticationCredentials !== undefined) {
                localVarQueryParameter['userAuthentication.credentials'] = userAuthenticationCredentials;
            }

            if (userAuthenticationDetails !== undefined) {
                localVarQueryParameter['userAuthentication.details'] = userAuthenticationDetails;
            }

            if (userAuthenticationPrincipal !== undefined) {
                localVarQueryParameter['userAuthentication.principal'] = userAuthenticationPrincipal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary user
         * @param {boolean} [oAuth2RequestApproved] 
         * @param {string} [oAuth2RequestAuthorities0Authority] 
         * @param {string} [oAuth2RequestGrantType] 
         * @param {string} [oAuth2RequestRedirectUri] 
         * @param {boolean} [oAuth2RequestRefresh] 
         * @param {string} [oAuth2RequestRefreshTokenRequestGrantType] 
         * @param {Array<string>} [oAuth2RequestResourceIds] 
         * @param {Array<string>} [oAuth2RequestResponseTypes] 
         * @param {boolean} [authenticated] 
         * @param {string} [authorities0Authority] 
         * @param {boolean} [clientOnly] 
         * @param {object} [credentials] 
         * @param {object} [details] 
         * @param {string} [name] 
         * @param {object} [principal] 
         * @param {boolean} [userAuthenticationAuthenticated] 
         * @param {string} [userAuthenticationAuthorities0Authority] 
         * @param {object} [userAuthenticationCredentials] 
         * @param {object} [userAuthenticationDetails] 
         * @param {object} [userAuthenticationPrincipal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUsingPOST: async (oAuth2RequestApproved?: boolean, oAuth2RequestAuthorities0Authority?: string, oAuth2RequestGrantType?: string, oAuth2RequestRedirectUri?: string, oAuth2RequestRefresh?: boolean, oAuth2RequestRefreshTokenRequestGrantType?: string, oAuth2RequestResourceIds?: Array<string>, oAuth2RequestResponseTypes?: Array<string>, authenticated?: boolean, authorities0Authority?: string, clientOnly?: boolean, credentials?: object, details?: object, name?: string, principal?: object, userAuthenticationAuthenticated?: boolean, userAuthenticationAuthorities0Authority?: string, userAuthenticationCredentials?: object, userAuthenticationDetails?: object, userAuthenticationPrincipal?: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth/ego-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (oAuth2RequestApproved !== undefined) {
                localVarQueryParameter['OAuth2Request.approved'] = oAuth2RequestApproved;
            }

            if (oAuth2RequestAuthorities0Authority !== undefined) {
                localVarQueryParameter['OAuth2Request.authorities[0].authority'] = oAuth2RequestAuthorities0Authority;
            }

            if (oAuth2RequestGrantType !== undefined) {
                localVarQueryParameter['OAuth2Request.grantType'] = oAuth2RequestGrantType;
            }

            if (oAuth2RequestRedirectUri !== undefined) {
                localVarQueryParameter['OAuth2Request.redirectUri'] = oAuth2RequestRedirectUri;
            }

            if (oAuth2RequestRefresh !== undefined) {
                localVarQueryParameter['OAuth2Request.refresh'] = oAuth2RequestRefresh;
            }

            if (oAuth2RequestRefreshTokenRequestGrantType !== undefined) {
                localVarQueryParameter['OAuth2Request.refreshTokenRequest.grantType'] = oAuth2RequestRefreshTokenRequestGrantType;
            }

            if (oAuth2RequestResourceIds) {
                localVarQueryParameter['OAuth2Request.resourceIds'] = oAuth2RequestResourceIds;
            }

            if (oAuth2RequestResponseTypes) {
                localVarQueryParameter['OAuth2Request.responseTypes'] = oAuth2RequestResponseTypes;
            }

            if (authenticated !== undefined) {
                localVarQueryParameter['authenticated'] = authenticated;
            }

            if (authorities0Authority !== undefined) {
                localVarQueryParameter['authorities[0].authority'] = authorities0Authority;
            }

            if (clientOnly !== undefined) {
                localVarQueryParameter['clientOnly'] = clientOnly;
            }

            if (credentials !== undefined) {
                localVarQueryParameter['credentials'] = credentials;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (principal !== undefined) {
                localVarQueryParameter['principal'] = principal;
            }

            if (userAuthenticationAuthenticated !== undefined) {
                localVarQueryParameter['userAuthentication.authenticated'] = userAuthenticationAuthenticated;
            }

            if (userAuthenticationAuthorities0Authority !== undefined) {
                localVarQueryParameter['userAuthentication.authorities[0].authority'] = userAuthenticationAuthorities0Authority;
            }

            if (userAuthenticationCredentials !== undefined) {
                localVarQueryParameter['userAuthentication.credentials'] = userAuthenticationCredentials;
            }

            if (userAuthenticationDetails !== undefined) {
                localVarQueryParameter['userAuthentication.details'] = userAuthenticationDetails;
            }

            if (userAuthenticationPrincipal !== undefined) {
                localVarQueryParameter['userAuthentication.principal'] = userAuthenticationPrincipal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary verifyJWToken
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyJWTokenUsingGET: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('verifyJWTokenUsingGET', 'token', token)
            const localVarPath = `/oauth/token/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (token !== undefined && token !== null) {
                localVarHeaderParameter['token'] = String(token);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary deleteRefreshToken
         * @param {string} [refreshId] refreshId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRefreshTokenUsingDELETE(refreshId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRefreshTokenUsingDELETE(refreshId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary exchangeFacebookTokenForAuth
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exchangeFacebookTokenForAuthUsingGET(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exchangeFacebookTokenForAuthUsingGET(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary exchangeGoogleTokenForAuth
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exchangeGoogleTokenForAuthUsingGET(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exchangeGoogleTokenForAuthUsingGET(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getPublicKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKeyUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKeyUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary postAccessToken
         * @param {string} clientId 
         * @param {string} clientSecret 
         * @param {string} grantType 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAccessTokenUsingPOST(clientId: string, clientSecret: string, grantType: string, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuth2AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAccessTokenUsingPOST(clientId, clientSecret, grantType, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary refreshEgoToken
         * @param {string} [refreshId] refreshId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshEgoTokenUsingPOST(refreshId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshEgoTokenUsingPOST(refreshId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updateEgoToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEgoTokenUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEgoTokenUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updateEgoToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEgoTokenUsingPOST(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEgoTokenUsingPOST(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary user
         * @param {boolean} [oAuth2RequestApproved] 
         * @param {string} [oAuth2RequestAuthorities0Authority] 
         * @param {string} [oAuth2RequestGrantType] 
         * @param {string} [oAuth2RequestRedirectUri] 
         * @param {boolean} [oAuth2RequestRefresh] 
         * @param {string} [oAuth2RequestRefreshTokenRequestGrantType] 
         * @param {Array<string>} [oAuth2RequestResourceIds] 
         * @param {Array<string>} [oAuth2RequestResponseTypes] 
         * @param {boolean} [authenticated] 
         * @param {string} [authorities0Authority] 
         * @param {boolean} [clientOnly] 
         * @param {object} [credentials] 
         * @param {object} [details] 
         * @param {string} [name] 
         * @param {object} [principal] 
         * @param {boolean} [userAuthenticationAuthenticated] 
         * @param {string} [userAuthenticationAuthorities0Authority] 
         * @param {object} [userAuthenticationCredentials] 
         * @param {object} [userAuthenticationDetails] 
         * @param {object} [userAuthenticationPrincipal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUsingGET(oAuth2RequestApproved?: boolean, oAuth2RequestAuthorities0Authority?: string, oAuth2RequestGrantType?: string, oAuth2RequestRedirectUri?: string, oAuth2RequestRefresh?: boolean, oAuth2RequestRefreshTokenRequestGrantType?: string, oAuth2RequestResourceIds?: Array<string>, oAuth2RequestResponseTypes?: Array<string>, authenticated?: boolean, authorities0Authority?: string, clientOnly?: boolean, credentials?: object, details?: object, name?: string, principal?: object, userAuthenticationAuthenticated?: boolean, userAuthenticationAuthorities0Authority?: string, userAuthenticationCredentials?: object, userAuthenticationDetails?: object, userAuthenticationPrincipal?: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUsingGET(oAuth2RequestApproved, oAuth2RequestAuthorities0Authority, oAuth2RequestGrantType, oAuth2RequestRedirectUri, oAuth2RequestRefresh, oAuth2RequestRefreshTokenRequestGrantType, oAuth2RequestResourceIds, oAuth2RequestResponseTypes, authenticated, authorities0Authority, clientOnly, credentials, details, name, principal, userAuthenticationAuthenticated, userAuthenticationAuthorities0Authority, userAuthenticationCredentials, userAuthenticationDetails, userAuthenticationPrincipal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary user
         * @param {boolean} [oAuth2RequestApproved] 
         * @param {string} [oAuth2RequestAuthorities0Authority] 
         * @param {string} [oAuth2RequestGrantType] 
         * @param {string} [oAuth2RequestRedirectUri] 
         * @param {boolean} [oAuth2RequestRefresh] 
         * @param {string} [oAuth2RequestRefreshTokenRequestGrantType] 
         * @param {Array<string>} [oAuth2RequestResourceIds] 
         * @param {Array<string>} [oAuth2RequestResponseTypes] 
         * @param {boolean} [authenticated] 
         * @param {string} [authorities0Authority] 
         * @param {boolean} [clientOnly] 
         * @param {object} [credentials] 
         * @param {object} [details] 
         * @param {string} [name] 
         * @param {object} [principal] 
         * @param {boolean} [userAuthenticationAuthenticated] 
         * @param {string} [userAuthenticationAuthorities0Authority] 
         * @param {object} [userAuthenticationCredentials] 
         * @param {object} [userAuthenticationDetails] 
         * @param {object} [userAuthenticationPrincipal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUsingPOST(oAuth2RequestApproved?: boolean, oAuth2RequestAuthorities0Authority?: string, oAuth2RequestGrantType?: string, oAuth2RequestRedirectUri?: string, oAuth2RequestRefresh?: boolean, oAuth2RequestRefreshTokenRequestGrantType?: string, oAuth2RequestResourceIds?: Array<string>, oAuth2RequestResponseTypes?: Array<string>, authenticated?: boolean, authorities0Authority?: string, clientOnly?: boolean, credentials?: object, details?: object, name?: string, principal?: object, userAuthenticationAuthenticated?: boolean, userAuthenticationAuthorities0Authority?: string, userAuthenticationCredentials?: object, userAuthenticationDetails?: object, userAuthenticationPrincipal?: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUsingPOST(oAuth2RequestApproved, oAuth2RequestAuthorities0Authority, oAuth2RequestGrantType, oAuth2RequestRedirectUri, oAuth2RequestRefresh, oAuth2RequestRefreshTokenRequestGrantType, oAuth2RequestResourceIds, oAuth2RequestResponseTypes, authenticated, authorities0Authority, clientOnly, credentials, details, name, principal, userAuthenticationAuthenticated, userAuthenticationAuthorities0Authority, userAuthenticationCredentials, userAuthenticationDetails, userAuthenticationPrincipal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary verifyJWToken
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyJWTokenUsingGET(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyJWTokenUsingGET(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary deleteRefreshToken
         * @param {string} [refreshId] refreshId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRefreshTokenUsingDELETE(refreshId?: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteRefreshTokenUsingDELETE(refreshId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary exchangeFacebookTokenForAuth
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangeFacebookTokenForAuthUsingGET(token: string, options?: any): AxiosPromise<string> {
            return localVarFp.exchangeFacebookTokenForAuthUsingGET(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary exchangeGoogleTokenForAuth
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangeGoogleTokenForAuthUsingGET(token: string, options?: any): AxiosPromise<string> {
            return localVarFp.exchangeGoogleTokenForAuthUsingGET(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getPublicKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeyUsingGET(options?: any): AxiosPromise<string> {
            return localVarFp.getPublicKeyUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary postAccessToken
         * @param {string} clientId 
         * @param {string} clientSecret 
         * @param {string} grantType 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccessTokenUsingPOST(clientId: string, clientSecret: string, grantType: string, name?: string, options?: any): AxiosPromise<OAuth2AccessToken> {
            return localVarFp.postAccessTokenUsingPOST(clientId, clientSecret, grantType, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary refreshEgoToken
         * @param {string} [refreshId] refreshId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshEgoTokenUsingPOST(refreshId?: string, options?: any): AxiosPromise<string> {
            return localVarFp.refreshEgoTokenUsingPOST(refreshId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateEgoToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEgoTokenUsingGET(options?: any): AxiosPromise<string> {
            return localVarFp.updateEgoTokenUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateEgoToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEgoTokenUsingPOST(options?: any): AxiosPromise<string> {
            return localVarFp.updateEgoTokenUsingPOST(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary user
         * @param {boolean} [oAuth2RequestApproved] 
         * @param {string} [oAuth2RequestAuthorities0Authority] 
         * @param {string} [oAuth2RequestGrantType] 
         * @param {string} [oAuth2RequestRedirectUri] 
         * @param {boolean} [oAuth2RequestRefresh] 
         * @param {string} [oAuth2RequestRefreshTokenRequestGrantType] 
         * @param {Array<string>} [oAuth2RequestResourceIds] 
         * @param {Array<string>} [oAuth2RequestResponseTypes] 
         * @param {boolean} [authenticated] 
         * @param {string} [authorities0Authority] 
         * @param {boolean} [clientOnly] 
         * @param {object} [credentials] 
         * @param {object} [details] 
         * @param {string} [name] 
         * @param {object} [principal] 
         * @param {boolean} [userAuthenticationAuthenticated] 
         * @param {string} [userAuthenticationAuthorities0Authority] 
         * @param {object} [userAuthenticationCredentials] 
         * @param {object} [userAuthenticationDetails] 
         * @param {object} [userAuthenticationPrincipal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUsingGET(oAuth2RequestApproved?: boolean, oAuth2RequestAuthorities0Authority?: string, oAuth2RequestGrantType?: string, oAuth2RequestRedirectUri?: string, oAuth2RequestRefresh?: boolean, oAuth2RequestRefreshTokenRequestGrantType?: string, oAuth2RequestResourceIds?: Array<string>, oAuth2RequestResponseTypes?: Array<string>, authenticated?: boolean, authorities0Authority?: string, clientOnly?: boolean, credentials?: object, details?: object, name?: string, principal?: object, userAuthenticationAuthenticated?: boolean, userAuthenticationAuthorities0Authority?: string, userAuthenticationCredentials?: object, userAuthenticationDetails?: object, userAuthenticationPrincipal?: object, options?: any): AxiosPromise<string> {
            return localVarFp.userUsingGET(oAuth2RequestApproved, oAuth2RequestAuthorities0Authority, oAuth2RequestGrantType, oAuth2RequestRedirectUri, oAuth2RequestRefresh, oAuth2RequestRefreshTokenRequestGrantType, oAuth2RequestResourceIds, oAuth2RequestResponseTypes, authenticated, authorities0Authority, clientOnly, credentials, details, name, principal, userAuthenticationAuthenticated, userAuthenticationAuthorities0Authority, userAuthenticationCredentials, userAuthenticationDetails, userAuthenticationPrincipal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary user
         * @param {boolean} [oAuth2RequestApproved] 
         * @param {string} [oAuth2RequestAuthorities0Authority] 
         * @param {string} [oAuth2RequestGrantType] 
         * @param {string} [oAuth2RequestRedirectUri] 
         * @param {boolean} [oAuth2RequestRefresh] 
         * @param {string} [oAuth2RequestRefreshTokenRequestGrantType] 
         * @param {Array<string>} [oAuth2RequestResourceIds] 
         * @param {Array<string>} [oAuth2RequestResponseTypes] 
         * @param {boolean} [authenticated] 
         * @param {string} [authorities0Authority] 
         * @param {boolean} [clientOnly] 
         * @param {object} [credentials] 
         * @param {object} [details] 
         * @param {string} [name] 
         * @param {object} [principal] 
         * @param {boolean} [userAuthenticationAuthenticated] 
         * @param {string} [userAuthenticationAuthorities0Authority] 
         * @param {object} [userAuthenticationCredentials] 
         * @param {object} [userAuthenticationDetails] 
         * @param {object} [userAuthenticationPrincipal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUsingPOST(oAuth2RequestApproved?: boolean, oAuth2RequestAuthorities0Authority?: string, oAuth2RequestGrantType?: string, oAuth2RequestRedirectUri?: string, oAuth2RequestRefresh?: boolean, oAuth2RequestRefreshTokenRequestGrantType?: string, oAuth2RequestResourceIds?: Array<string>, oAuth2RequestResponseTypes?: Array<string>, authenticated?: boolean, authorities0Authority?: string, clientOnly?: boolean, credentials?: object, details?: object, name?: string, principal?: object, userAuthenticationAuthenticated?: boolean, userAuthenticationAuthorities0Authority?: string, userAuthenticationCredentials?: object, userAuthenticationDetails?: object, userAuthenticationPrincipal?: object, options?: any): AxiosPromise<string> {
            return localVarFp.userUsingPOST(oAuth2RequestApproved, oAuth2RequestAuthorities0Authority, oAuth2RequestGrantType, oAuth2RequestRedirectUri, oAuth2RequestRefresh, oAuth2RequestRefreshTokenRequestGrantType, oAuth2RequestResourceIds, oAuth2RequestResponseTypes, authenticated, authorities0Authority, clientOnly, credentials, details, name, principal, userAuthenticationAuthenticated, userAuthenticationAuthorities0Authority, userAuthenticationCredentials, userAuthenticationDetails, userAuthenticationPrincipal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary verifyJWToken
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyJWTokenUsingGET(token: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.verifyJWTokenUsingGET(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary deleteRefreshToken
     * @param {string} [refreshId] refreshId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public deleteRefreshTokenUsingDELETE(refreshId?: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).deleteRefreshTokenUsingDELETE(refreshId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary exchangeFacebookTokenForAuth
     * @param {string} token token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public exchangeFacebookTokenForAuthUsingGET(token: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).exchangeFacebookTokenForAuthUsingGET(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary exchangeGoogleTokenForAuth
     * @param {string} token token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public exchangeGoogleTokenForAuthUsingGET(token: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).exchangeGoogleTokenForAuthUsingGET(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getPublicKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getPublicKeyUsingGET(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).getPublicKeyUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary postAccessToken
     * @param {string} clientId 
     * @param {string} clientSecret 
     * @param {string} grantType 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postAccessTokenUsingPOST(clientId: string, clientSecret: string, grantType: string, name?: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).postAccessTokenUsingPOST(clientId, clientSecret, grantType, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary refreshEgoToken
     * @param {string} [refreshId] refreshId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refreshEgoTokenUsingPOST(refreshId?: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).refreshEgoTokenUsingPOST(refreshId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateEgoToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public updateEgoTokenUsingGET(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).updateEgoTokenUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateEgoToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public updateEgoTokenUsingPOST(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).updateEgoTokenUsingPOST(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary user
     * @param {boolean} [oAuth2RequestApproved] 
     * @param {string} [oAuth2RequestAuthorities0Authority] 
     * @param {string} [oAuth2RequestGrantType] 
     * @param {string} [oAuth2RequestRedirectUri] 
     * @param {boolean} [oAuth2RequestRefresh] 
     * @param {string} [oAuth2RequestRefreshTokenRequestGrantType] 
     * @param {Array<string>} [oAuth2RequestResourceIds] 
     * @param {Array<string>} [oAuth2RequestResponseTypes] 
     * @param {boolean} [authenticated] 
     * @param {string} [authorities0Authority] 
     * @param {boolean} [clientOnly] 
     * @param {object} [credentials] 
     * @param {object} [details] 
     * @param {string} [name] 
     * @param {object} [principal] 
     * @param {boolean} [userAuthenticationAuthenticated] 
     * @param {string} [userAuthenticationAuthorities0Authority] 
     * @param {object} [userAuthenticationCredentials] 
     * @param {object} [userAuthenticationDetails] 
     * @param {object} [userAuthenticationPrincipal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public userUsingGET(oAuth2RequestApproved?: boolean, oAuth2RequestAuthorities0Authority?: string, oAuth2RequestGrantType?: string, oAuth2RequestRedirectUri?: string, oAuth2RequestRefresh?: boolean, oAuth2RequestRefreshTokenRequestGrantType?: string, oAuth2RequestResourceIds?: Array<string>, oAuth2RequestResponseTypes?: Array<string>, authenticated?: boolean, authorities0Authority?: string, clientOnly?: boolean, credentials?: object, details?: object, name?: string, principal?: object, userAuthenticationAuthenticated?: boolean, userAuthenticationAuthorities0Authority?: string, userAuthenticationCredentials?: object, userAuthenticationDetails?: object, userAuthenticationPrincipal?: object, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).userUsingGET(oAuth2RequestApproved, oAuth2RequestAuthorities0Authority, oAuth2RequestGrantType, oAuth2RequestRedirectUri, oAuth2RequestRefresh, oAuth2RequestRefreshTokenRequestGrantType, oAuth2RequestResourceIds, oAuth2RequestResponseTypes, authenticated, authorities0Authority, clientOnly, credentials, details, name, principal, userAuthenticationAuthenticated, userAuthenticationAuthorities0Authority, userAuthenticationCredentials, userAuthenticationDetails, userAuthenticationPrincipal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary user
     * @param {boolean} [oAuth2RequestApproved] 
     * @param {string} [oAuth2RequestAuthorities0Authority] 
     * @param {string} [oAuth2RequestGrantType] 
     * @param {string} [oAuth2RequestRedirectUri] 
     * @param {boolean} [oAuth2RequestRefresh] 
     * @param {string} [oAuth2RequestRefreshTokenRequestGrantType] 
     * @param {Array<string>} [oAuth2RequestResourceIds] 
     * @param {Array<string>} [oAuth2RequestResponseTypes] 
     * @param {boolean} [authenticated] 
     * @param {string} [authorities0Authority] 
     * @param {boolean} [clientOnly] 
     * @param {object} [credentials] 
     * @param {object} [details] 
     * @param {string} [name] 
     * @param {object} [principal] 
     * @param {boolean} [userAuthenticationAuthenticated] 
     * @param {string} [userAuthenticationAuthorities0Authority] 
     * @param {object} [userAuthenticationCredentials] 
     * @param {object} [userAuthenticationDetails] 
     * @param {object} [userAuthenticationPrincipal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public userUsingPOST(oAuth2RequestApproved?: boolean, oAuth2RequestAuthorities0Authority?: string, oAuth2RequestGrantType?: string, oAuth2RequestRedirectUri?: string, oAuth2RequestRefresh?: boolean, oAuth2RequestRefreshTokenRequestGrantType?: string, oAuth2RequestResourceIds?: Array<string>, oAuth2RequestResponseTypes?: Array<string>, authenticated?: boolean, authorities0Authority?: string, clientOnly?: boolean, credentials?: object, details?: object, name?: string, principal?: object, userAuthenticationAuthenticated?: boolean, userAuthenticationAuthorities0Authority?: string, userAuthenticationCredentials?: object, userAuthenticationDetails?: object, userAuthenticationPrincipal?: object, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).userUsingPOST(oAuth2RequestApproved, oAuth2RequestAuthorities0Authority, oAuth2RequestGrantType, oAuth2RequestRedirectUri, oAuth2RequestRefresh, oAuth2RequestRefreshTokenRequestGrantType, oAuth2RequestResourceIds, oAuth2RequestResponseTypes, authenticated, authorities0Authority, clientOnly, credentials, details, name, principal, userAuthenticationAuthenticated, userAuthenticationAuthorities0Authority, userAuthenticationCredentials, userAuthenticationDetails, userAuthenticationPrincipal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary verifyJWToken
     * @param {string} token token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public verifyJWTokenUsingGET(token: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).verifyJWTokenUsingGET(token, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addApplicationsToGroup
         * @param {string} id id
         * @param {Array<string>} appIds appIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addApplicationsToGroupUsingPOST: async (id: string, appIds: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addApplicationsToGroupUsingPOST', 'id', id)
            // verify required parameter 'appIds' is not null or undefined
            assertParamExists('addApplicationsToGroupUsingPOST', 'appIds', appIds)
            const localVarPath = `/groups/{id}/applications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(appIds, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary addPermissions
         * @param {string} id id
         * @param {Array<PermissionRequest>} permissions permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPermissionsUsingPOST1: async (id: string, permissions: Array<PermissionRequest>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addPermissionsUsingPOST1', 'id', id)
            // verify required parameter 'permissions' is not null or undefined
            assertParamExists('addPermissionsUsingPOST1', 'permissions', permissions)
            const localVarPath = `/groups/{id}/permissions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(permissions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary addUsersToGroup
         * @param {string} id id
         * @param {Array<string>} userIds userIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToGroupUsingPOST: async (id: string, userIds: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addUsersToGroupUsingPOST', 'id', id)
            // verify required parameter 'userIds' is not null or undefined
            assertParamExists('addUsersToGroupUsingPOST', 'userIds', userIds)
            const localVarPath = `/groups/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userIds, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createGroup
         * @param {GroupRequest} createRequest createRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupUsingPOST: async (createRequest: GroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRequest' is not null or undefined
            assertParamExists('createGroupUsingPOST', 'createRequest', createRequest)
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteApplicationsFromGroup
         * @param {string} appIds appIds
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationsFromGroupUsingDELETE: async (appIds: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appIds' is not null or undefined
            assertParamExists('deleteApplicationsFromGroupUsingDELETE', 'appIds', appIds)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteApplicationsFromGroupUsingDELETE', 'id', id)
            const localVarPath = `/groups/{id}/applications/{appIds}`
                .replace(`{${"appIds"}}`, encodeURIComponent(String(appIds)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteGroup
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupUsingDELETE: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGroupUsingDELETE', 'id', id)
            const localVarPath = `/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deletePermissions
         * @param {string} id id
         * @param {string} permissionIds permissionIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermissionsUsingDELETE1: async (id: string, permissionIds: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePermissionsUsingDELETE1', 'id', id)
            // verify required parameter 'permissionIds' is not null or undefined
            assertParamExists('deletePermissionsUsingDELETE1', 'permissionIds', permissionIds)
            const localVarPath = `/groups/{id}/permissions/{permissionIds}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"permissionIds"}}`, encodeURIComponent(String(permissionIds)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteUsersFromGroup
         * @param {string} id id
         * @param {string} userIds userIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersFromGroupUsingDELETE: async (id: string, userIds: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUsersFromGroupUsingDELETE', 'id', id)
            // verify required parameter 'userIds' is not null or undefined
            assertParamExists('deleteUsersFromGroupUsingDELETE', 'userIds', userIds)
            const localVarPath = `/groups/{id}/users/{userIds}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userIds"}}`, encodeURIComponent(String(userIds)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getApplicationsForGroup
         * @param {string} id Search for ids containing this text
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] query
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationsForGroupUsingGET: async (id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getApplicationsForGroupUsingGET', 'id', id)
            const localVarPath = `/groups/{id}/applications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getGroupPermissionsForGroup
         * @param {string} id Search for ids containing this text
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPermissionsForGroupUsingGET: async (id: string, limit?: string, offset?: string, sort?: string, sortOrder?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGroupPermissionsForGroupUsingGET', 'id', id)
            const localVarPath = `/groups/{id}/permissions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getGroup
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupUsingGET: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGroupUsingGET', 'id', id)
            const localVarPath = `/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUsersForGroup
         * @param {string} id Search for ids containing this text
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] query
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersForGroupUsingGET: async (id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersForGroupUsingGET', 'id', id)
            const localVarPath = `/groups/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listGroups
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] query
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroupsUsingGET: async (limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateGroup
         * @param {string} id id
         * @param {GroupRequest} updateRequest updateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupUsingPUT: async (id: string, updateRequest: GroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateGroupUsingPUT', 'id', id)
            // verify required parameter 'updateRequest' is not null or undefined
            assertParamExists('updateGroupUsingPUT', 'updateRequest', updateRequest)
            const localVarPath = `/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary addApplicationsToGroup
         * @param {string} id id
         * @param {Array<string>} appIds appIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addApplicationsToGroupUsingPOST(id: string, appIds: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addApplicationsToGroupUsingPOST(id, appIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary addPermissions
         * @param {string} id id
         * @param {Array<PermissionRequest>} permissions permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPermissionsUsingPOST1(id: string, permissions: Array<PermissionRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPermissionsUsingPOST1(id, permissions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary addUsersToGroup
         * @param {string} id id
         * @param {Array<string>} userIds userIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUsersToGroupUsingPOST(id: string, userIds: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUsersToGroupUsingPOST(id, userIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary createGroup
         * @param {GroupRequest} createRequest createRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroupUsingPOST(createRequest: GroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroupUsingPOST(createRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deleteApplicationsFromGroup
         * @param {string} appIds appIds
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationsFromGroupUsingDELETE(appIds: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationsFromGroupUsingDELETE(appIds, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deleteGroup
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupUsingDELETE(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupUsingDELETE(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deletePermissions
         * @param {string} id id
         * @param {string} permissionIds permissionIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePermissionsUsingDELETE1(id: string, permissionIds: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePermissionsUsingDELETE1(id, permissionIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deleteUsersFromGroup
         * @param {string} id id
         * @param {string} userIds userIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsersFromGroupUsingDELETE(id: string, userIds: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUsersFromGroupUsingDELETE(id, userIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getApplicationsForGroup
         * @param {string} id Search for ids containing this text
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] query
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationsForGroupUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDTOApplication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationsForGroupUsingGET(id, limit, offset, query, sort, sortOrder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getGroupPermissionsForGroup
         * @param {string} id Search for ids containing this text
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupPermissionsForGroupUsingGET(id: string, limit?: string, offset?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDTOGroupPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupPermissionsForGroupUsingGET(id, limit, offset, sort, sortOrder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getGroup
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupUsingGET(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupUsingGET(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getUsersForGroup
         * @param {string} id Search for ids containing this text
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] query
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersForGroupUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDTOUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersForGroupUsingGET(id, limit, offset, query, sort, sortOrder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary listGroups
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] query
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroupsUsingGET(limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDTOGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroupsUsingGET(limit, offset, query, sort, sortOrder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updateGroup
         * @param {string} id id
         * @param {GroupRequest} updateRequest updateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupUsingPUT(id: string, updateRequest: GroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupUsingPUT(id, updateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary addApplicationsToGroup
         * @param {string} id id
         * @param {Array<string>} appIds appIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addApplicationsToGroupUsingPOST(id: string, appIds: Array<string>, options?: any): AxiosPromise<Group> {
            return localVarFp.addApplicationsToGroupUsingPOST(id, appIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary addPermissions
         * @param {string} id id
         * @param {Array<PermissionRequest>} permissions permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPermissionsUsingPOST1(id: string, permissions: Array<PermissionRequest>, options?: any): AxiosPromise<Group> {
            return localVarFp.addPermissionsUsingPOST1(id, permissions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary addUsersToGroup
         * @param {string} id id
         * @param {Array<string>} userIds userIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToGroupUsingPOST(id: string, userIds: Array<string>, options?: any): AxiosPromise<Group> {
            return localVarFp.addUsersToGroupUsingPOST(id, userIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary createGroup
         * @param {GroupRequest} createRequest createRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupUsingPOST(createRequest: GroupRequest, options?: any): AxiosPromise<Group> {
            return localVarFp.createGroupUsingPOST(createRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteApplicationsFromGroup
         * @param {string} appIds appIds
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationsFromGroupUsingDELETE(appIds: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplicationsFromGroupUsingDELETE(appIds, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteGroup
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupUsingDELETE(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroupUsingDELETE(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deletePermissions
         * @param {string} id id
         * @param {string} permissionIds permissionIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermissionsUsingDELETE1(id: string, permissionIds: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePermissionsUsingDELETE1(id, permissionIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteUsersFromGroup
         * @param {string} id id
         * @param {string} userIds userIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersFromGroupUsingDELETE(id: string, userIds: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUsersFromGroupUsingDELETE(id, userIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getApplicationsForGroup
         * @param {string} id Search for ids containing this text
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] query
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationsForGroupUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: any): AxiosPromise<PageDTOApplication> {
            return localVarFp.getApplicationsForGroupUsingGET(id, limit, offset, query, sort, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getGroupPermissionsForGroup
         * @param {string} id Search for ids containing this text
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPermissionsForGroupUsingGET(id: string, limit?: string, offset?: string, sort?: string, sortOrder?: string, options?: any): AxiosPromise<PageDTOGroupPermission> {
            return localVarFp.getGroupPermissionsForGroupUsingGET(id, limit, offset, sort, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getGroup
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupUsingGET(id: string, options?: any): AxiosPromise<Group> {
            return localVarFp.getGroupUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getUsersForGroup
         * @param {string} id Search for ids containing this text
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] query
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersForGroupUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: any): AxiosPromise<PageDTOUser> {
            return localVarFp.getUsersForGroupUsingGET(id, limit, offset, query, sort, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary listGroups
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] query
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroupsUsingGET(limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: any): AxiosPromise<PageDTOGroup> {
            return localVarFp.listGroupsUsingGET(limit, offset, query, sort, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateGroup
         * @param {string} id id
         * @param {GroupRequest} updateRequest updateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupUsingPUT(id: string, updateRequest: GroupRequest, options?: any): AxiosPromise<Group> {
            return localVarFp.updateGroupUsingPUT(id, updateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * 
     * @summary addApplicationsToGroup
     * @param {string} id id
     * @param {Array<string>} appIds appIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public addApplicationsToGroupUsingPOST(id: string, appIds: Array<string>, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).addApplicationsToGroupUsingPOST(id, appIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary addPermissions
     * @param {string} id id
     * @param {Array<PermissionRequest>} permissions permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public addPermissionsUsingPOST1(id: string, permissions: Array<PermissionRequest>, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).addPermissionsUsingPOST1(id, permissions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary addUsersToGroup
     * @param {string} id id
     * @param {Array<string>} userIds userIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public addUsersToGroupUsingPOST(id: string, userIds: Array<string>, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).addUsersToGroupUsingPOST(id, userIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary createGroup
     * @param {GroupRequest} createRequest createRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public createGroupUsingPOST(createRequest: GroupRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).createGroupUsingPOST(createRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteApplicationsFromGroup
     * @param {string} appIds appIds
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteApplicationsFromGroupUsingDELETE(appIds: string, id: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteApplicationsFromGroupUsingDELETE(appIds, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteGroup
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteGroupUsingDELETE(id: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteGroupUsingDELETE(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deletePermissions
     * @param {string} id id
     * @param {string} permissionIds permissionIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deletePermissionsUsingDELETE1(id: string, permissionIds: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deletePermissionsUsingDELETE1(id, permissionIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteUsersFromGroup
     * @param {string} id id
     * @param {string} userIds userIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteUsersFromGroupUsingDELETE(id: string, userIds: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteUsersFromGroupUsingDELETE(id, userIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getApplicationsForGroup
     * @param {string} id Search for ids containing this text
     * @param {string} [limit] Number of results to retrieve
     * @param {string} [offset] Index of first result to retrieve
     * @param {string} [query] query
     * @param {string} [sort] Field to sort on
     * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getApplicationsForGroupUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getApplicationsForGroupUsingGET(id, limit, offset, query, sort, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getGroupPermissionsForGroup
     * @param {string} id Search for ids containing this text
     * @param {string} [limit] Number of results to retrieve
     * @param {string} [offset] Index of first result to retrieve
     * @param {string} [sort] Field to sort on
     * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupPermissionsForGroupUsingGET(id: string, limit?: string, offset?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupPermissionsForGroupUsingGET(id, limit, offset, sort, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getGroup
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupUsingGET(id: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getUsersForGroup
     * @param {string} id Search for ids containing this text
     * @param {string} [limit] Number of results to retrieve
     * @param {string} [offset] Index of first result to retrieve
     * @param {string} [query] query
     * @param {string} [sort] Field to sort on
     * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getUsersForGroupUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getUsersForGroupUsingGET(id, limit, offset, query, sort, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary listGroups
     * @param {string} [limit] Number of results to retrieve
     * @param {string} [offset] Index of first result to retrieve
     * @param {string} [query] query
     * @param {string} [sort] Field to sort on
     * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public listGroupsUsingGET(limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).listGroupsUsingGET(limit, offset, query, sort, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateGroup
     * @param {string} id id
     * @param {GroupRequest} updateRequest updateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public updateGroupUsingPUT(id: string, updateRequest: GroupRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).updateGroupUsingPUT(id, updateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PoliciesApi - axios parameter creator
 * @export
 */
export const PoliciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createApplicationPermission
         * @param {string} applicationId application_id
         * @param {string} id id
         * @param {MaskDTO} maskDTO maskDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationPermissionUsingPOST: async (applicationId: string, id: string, maskDTO: MaskDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationPermissionUsingPOST', 'applicationId', applicationId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createApplicationPermissionUsingPOST', 'id', id)
            // verify required parameter 'maskDTO' is not null or undefined
            assertParamExists('createApplicationPermissionUsingPOST', 'maskDTO', maskDTO)
            const localVarPath = `/policies/{id}/permission/application/{application_id}`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(maskDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createGroupPermission
         * @param {string} groupId group_id
         * @param {string} id id
         * @param {MaskDTO} maskDTO maskDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupPermissionUsingPOST: async (groupId: string, id: string, maskDTO: MaskDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('createGroupPermissionUsingPOST', 'groupId', groupId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createGroupPermissionUsingPOST', 'id', id)
            // verify required parameter 'maskDTO' is not null or undefined
            assertParamExists('createGroupPermissionUsingPOST', 'maskDTO', maskDTO)
            const localVarPath = `/policies/{id}/permission/group/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(maskDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createPolicy
         * @param {PolicyRequest} createRequest createRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicyUsingPOST: async (createRequest: PolicyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRequest' is not null or undefined
            assertParamExists('createPolicyUsingPOST', 'createRequest', createRequest)
            const localVarPath = `/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createUserPermission
         * @param {string} id id
         * @param {string} userId user_id
         * @param {MaskDTO} maskDTO maskDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserPermissionUsingPOST: async (id: string, userId: string, maskDTO: MaskDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createUserPermissionUsingPOST', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createUserPermissionUsingPOST', 'userId', userId)
            // verify required parameter 'maskDTO' is not null or undefined
            assertParamExists('createUserPermissionUsingPOST', 'maskDTO', maskDTO)
            const localVarPath = `/policies/{id}/permission/user/{user_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(maskDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteApplicationPermission
         * @param {string} applicationId application_id
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationPermissionUsingDELETE: async (applicationId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplicationPermissionUsingDELETE', 'applicationId', applicationId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteApplicationPermissionUsingDELETE', 'id', id)
            const localVarPath = `/policies/{id}/permission/application/{application_id}`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteGroupPermission
         * @param {string} groupId group_id
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupPermissionUsingDELETE: async (groupId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteGroupPermissionUsingDELETE', 'groupId', groupId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGroupPermissionUsingDELETE', 'id', id)
            const localVarPath = `/policies/{id}/permission/group/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deletePolicy
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicyUsingDELETE: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePolicyUsingDELETE', 'id', id)
            const localVarPath = `/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteUserPermission
         * @param {string} id id
         * @param {string} userId user_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserPermissionUsingDELETE: async (id: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUserPermissionUsingDELETE', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserPermissionUsingDELETE', 'userId', userId)
            const localVarPath = `/policies/{id}/permission/user/{user_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findApplicationIds
         * @param {string} id id
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] Query string compares to AccessLevel and Application Id and Name fields.
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC. Note: ascending sort order for the mask field is: READ,WRITE,DENY
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findApplicationIdsUsingGET: async (id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findApplicationIdsUsingGET', 'id', id)
            const localVarPath = `/policies/{id}/applications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findGroupIds
         * @param {string} id id
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] Query string compares to AccessLevel and group Id and Name fields.
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC. Note: ascending sort order for the mask field is: READ,WRITE,DENY
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupIdsUsingGET: async (id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findGroupIdsUsingGET', 'id', id)
            const localVarPath = `/policies/{id}/groups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findUserIds
         * @param {string} id id
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] Query string compares to AccessLevel and user Id field.
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC. Note: ascending sort order for the mask field is: READ,WRITE,DENY
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserIdsUsingGET: async (id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findUserIdsUsingGET', 'id', id)
            const localVarPath = `/policies/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getPolicy
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyUsingGET: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPolicyUsingGET', 'id', id)
            const localVarPath = `/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listPolicies
         * @param {string} [id] Search for ids containing this text
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [name] Search for policies whose names contain this text
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPoliciesUsingGET: async (id?: string, limit?: string, name?: string, offset?: string, sort?: string, sortOrder?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updatePolicy
         * @param {string} id id
         * @param {PolicyRequest} updatedRequst updatedRequst
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicyUsingPUT: async (id: string, updatedRequst: PolicyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePolicyUsingPUT', 'id', id)
            // verify required parameter 'updatedRequst' is not null or undefined
            assertParamExists('updatePolicyUsingPUT', 'updatedRequst', updatedRequst)
            const localVarPath = `/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatedRequst, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoliciesApi - functional programming interface
 * @export
 */
export const PoliciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PoliciesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary createApplicationPermission
         * @param {string} applicationId application_id
         * @param {string} id id
         * @param {MaskDTO} maskDTO maskDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationPermissionUsingPOST(applicationId: string, id: string, maskDTO: MaskDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationPermissionUsingPOST(applicationId, id, maskDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary createGroupPermission
         * @param {string} groupId group_id
         * @param {string} id id
         * @param {MaskDTO} maskDTO maskDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroupPermissionUsingPOST(groupId: string, id: string, maskDTO: MaskDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroupPermissionUsingPOST(groupId, id, maskDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary createPolicy
         * @param {PolicyRequest} createRequest createRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolicyUsingPOST(createRequest: PolicyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolicyUsingPOST(createRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary createUserPermission
         * @param {string} id id
         * @param {string} userId user_id
         * @param {MaskDTO} maskDTO maskDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserPermissionUsingPOST(id: string, userId: string, maskDTO: MaskDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserPermissionUsingPOST(id, userId, maskDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deleteApplicationPermission
         * @param {string} applicationId application_id
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationPermissionUsingDELETE(applicationId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationPermissionUsingDELETE(applicationId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deleteGroupPermission
         * @param {string} groupId group_id
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupPermissionUsingDELETE(groupId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupPermissionUsingDELETE(groupId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deletePolicy
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePolicyUsingDELETE(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePolicyUsingDELETE(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deleteUserPermission
         * @param {string} id id
         * @param {string} userId user_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserPermissionUsingDELETE(id: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserPermissionUsingDELETE(id, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary findApplicationIds
         * @param {string} id id
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] Query string compares to AccessLevel and Application Id and Name fields.
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC. Note: ascending sort order for the mask field is: READ,WRITE,DENY
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findApplicationIdsUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findApplicationIdsUsingGET(id, limit, offset, query, sort, sortOrder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary findGroupIds
         * @param {string} id id
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] Query string compares to AccessLevel and group Id and Name fields.
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC. Note: ascending sort order for the mask field is: READ,WRITE,DENY
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findGroupIdsUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findGroupIdsUsingGET(id, limit, offset, query, sort, sortOrder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary findUserIds
         * @param {string} id id
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] Query string compares to AccessLevel and user Id field.
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC. Note: ascending sort order for the mask field is: READ,WRITE,DENY
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUserIdsUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUserIdsUsingGET(id, limit, offset, query, sort, sortOrder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getPolicy
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicyUsingGET(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicyUsingGET(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary listPolicies
         * @param {string} [id] Search for ids containing this text
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [name] Search for policies whose names contain this text
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPoliciesUsingGET(id?: string, limit?: string, name?: string, offset?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDTOPolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPoliciesUsingGET(id, limit, name, offset, sort, sortOrder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updatePolicy
         * @param {string} id id
         * @param {PolicyRequest} updatedRequst updatedRequst
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePolicyUsingPUT(id: string, updatedRequst: PolicyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePolicyUsingPUT(id, updatedRequst, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PoliciesApi - factory interface
 * @export
 */
export const PoliciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoliciesApiFp(configuration)
    return {
        /**
         * 
         * @summary createApplicationPermission
         * @param {string} applicationId application_id
         * @param {string} id id
         * @param {MaskDTO} maskDTO maskDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationPermissionUsingPOST(applicationId: string, id: string, maskDTO: MaskDTO, options?: any): AxiosPromise<string> {
            return localVarFp.createApplicationPermissionUsingPOST(applicationId, id, maskDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary createGroupPermission
         * @param {string} groupId group_id
         * @param {string} id id
         * @param {MaskDTO} maskDTO maskDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupPermissionUsingPOST(groupId: string, id: string, maskDTO: MaskDTO, options?: any): AxiosPromise<string> {
            return localVarFp.createGroupPermissionUsingPOST(groupId, id, maskDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary createPolicy
         * @param {PolicyRequest} createRequest createRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicyUsingPOST(createRequest: PolicyRequest, options?: any): AxiosPromise<Policy> {
            return localVarFp.createPolicyUsingPOST(createRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary createUserPermission
         * @param {string} id id
         * @param {string} userId user_id
         * @param {MaskDTO} maskDTO maskDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserPermissionUsingPOST(id: string, userId: string, maskDTO: MaskDTO, options?: any): AxiosPromise<string> {
            return localVarFp.createUserPermissionUsingPOST(id, userId, maskDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteApplicationPermission
         * @param {string} applicationId application_id
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationPermissionUsingDELETE(applicationId: string, id: string, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.deleteApplicationPermissionUsingDELETE(applicationId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteGroupPermission
         * @param {string} groupId group_id
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupPermissionUsingDELETE(groupId: string, id: string, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.deleteGroupPermissionUsingDELETE(groupId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deletePolicy
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicyUsingDELETE(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePolicyUsingDELETE(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteUserPermission
         * @param {string} id id
         * @param {string} userId user_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserPermissionUsingDELETE(id: string, userId: string, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.deleteUserPermissionUsingDELETE(id, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary findApplicationIds
         * @param {string} id id
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] Query string compares to AccessLevel and Application Id and Name fields.
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC. Note: ascending sort order for the mask field is: READ,WRITE,DENY
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findApplicationIdsUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: any): AxiosPromise<string> {
            return localVarFp.findApplicationIdsUsingGET(id, limit, offset, query, sort, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary findGroupIds
         * @param {string} id id
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] Query string compares to AccessLevel and group Id and Name fields.
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC. Note: ascending sort order for the mask field is: READ,WRITE,DENY
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupIdsUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: any): AxiosPromise<string> {
            return localVarFp.findGroupIdsUsingGET(id, limit, offset, query, sort, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary findUserIds
         * @param {string} id id
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] Query string compares to AccessLevel and user Id field.
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC. Note: ascending sort order for the mask field is: READ,WRITE,DENY
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserIdsUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: any): AxiosPromise<string> {
            return localVarFp.findUserIdsUsingGET(id, limit, offset, query, sort, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getPolicy
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyUsingGET(id: string, options?: any): AxiosPromise<Policy> {
            return localVarFp.getPolicyUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary listPolicies
         * @param {string} [id] Search for ids containing this text
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [name] Search for policies whose names contain this text
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPoliciesUsingGET(id?: string, limit?: string, name?: string, offset?: string, sort?: string, sortOrder?: string, options?: any): AxiosPromise<PageDTOPolicy> {
            return localVarFp.listPoliciesUsingGET(id, limit, name, offset, sort, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updatePolicy
         * @param {string} id id
         * @param {PolicyRequest} updatedRequst updatedRequst
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicyUsingPUT(id: string, updatedRequst: PolicyRequest, options?: any): AxiosPromise<Policy> {
            return localVarFp.updatePolicyUsingPUT(id, updatedRequst, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PoliciesApi - object-oriented interface
 * @export
 * @class PoliciesApi
 * @extends {BaseAPI}
 */
export class PoliciesApi extends BaseAPI {
    /**
     * 
     * @summary createApplicationPermission
     * @param {string} applicationId application_id
     * @param {string} id id
     * @param {MaskDTO} maskDTO maskDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public createApplicationPermissionUsingPOST(applicationId: string, id: string, maskDTO: MaskDTO, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).createApplicationPermissionUsingPOST(applicationId, id, maskDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary createGroupPermission
     * @param {string} groupId group_id
     * @param {string} id id
     * @param {MaskDTO} maskDTO maskDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public createGroupPermissionUsingPOST(groupId: string, id: string, maskDTO: MaskDTO, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).createGroupPermissionUsingPOST(groupId, id, maskDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary createPolicy
     * @param {PolicyRequest} createRequest createRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public createPolicyUsingPOST(createRequest: PolicyRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).createPolicyUsingPOST(createRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary createUserPermission
     * @param {string} id id
     * @param {string} userId user_id
     * @param {MaskDTO} maskDTO maskDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public createUserPermissionUsingPOST(id: string, userId: string, maskDTO: MaskDTO, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).createUserPermissionUsingPOST(id, userId, maskDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteApplicationPermission
     * @param {string} applicationId application_id
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public deleteApplicationPermissionUsingDELETE(applicationId: string, id: string, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).deleteApplicationPermissionUsingDELETE(applicationId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteGroupPermission
     * @param {string} groupId group_id
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public deleteGroupPermissionUsingDELETE(groupId: string, id: string, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).deleteGroupPermissionUsingDELETE(groupId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deletePolicy
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public deletePolicyUsingDELETE(id: string, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).deletePolicyUsingDELETE(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteUserPermission
     * @param {string} id id
     * @param {string} userId user_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public deleteUserPermissionUsingDELETE(id: string, userId: string, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).deleteUserPermissionUsingDELETE(id, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary findApplicationIds
     * @param {string} id id
     * @param {string} [limit] Number of results to retrieve
     * @param {string} [offset] Index of first result to retrieve
     * @param {string} [query] Query string compares to AccessLevel and Application Id and Name fields.
     * @param {string} [sort] Field to sort on
     * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC. Note: ascending sort order for the mask field is: READ,WRITE,DENY
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public findApplicationIdsUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).findApplicationIdsUsingGET(id, limit, offset, query, sort, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary findGroupIds
     * @param {string} id id
     * @param {string} [limit] Number of results to retrieve
     * @param {string} [offset] Index of first result to retrieve
     * @param {string} [query] Query string compares to AccessLevel and group Id and Name fields.
     * @param {string} [sort] Field to sort on
     * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC. Note: ascending sort order for the mask field is: READ,WRITE,DENY
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public findGroupIdsUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).findGroupIdsUsingGET(id, limit, offset, query, sort, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary findUserIds
     * @param {string} id id
     * @param {string} [limit] Number of results to retrieve
     * @param {string} [offset] Index of first result to retrieve
     * @param {string} [query] Query string compares to AccessLevel and user Id field.
     * @param {string} [sort] Field to sort on
     * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC. Note: ascending sort order for the mask field is: READ,WRITE,DENY
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public findUserIdsUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).findUserIdsUsingGET(id, limit, offset, query, sort, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getPolicy
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public getPolicyUsingGET(id: string, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).getPolicyUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary listPolicies
     * @param {string} [id] Search for ids containing this text
     * @param {string} [limit] Number of results to retrieve
     * @param {string} [name] Search for policies whose names contain this text
     * @param {string} [offset] Index of first result to retrieve
     * @param {string} [sort] Field to sort on
     * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public listPoliciesUsingGET(id?: string, limit?: string, name?: string, offset?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).listPoliciesUsingGET(id, limit, name, offset, sort, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updatePolicy
     * @param {string} id id
     * @param {PolicyRequest} updatedRequst updatedRequst
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public updatePolicyUsingPUT(id: string, updatedRequst: PolicyRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).updatePolicyUsingPUT(id, updatedRequst, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createGroupPermissions
         * @param {string} authorization Authorization
         * @param {Array<TransactionalGroupPermissionRequest>} requests requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupPermissionsUsingPOST: async (authorization: string, requests: Array<TransactionalGroupPermissionRequest>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('createGroupPermissionsUsingPOST', 'authorization', authorization)
            // verify required parameter 'requests' is not null or undefined
            assertParamExists('createGroupPermissionsUsingPOST', 'requests', requests)
            const localVarPath = `/transaction/group_permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requests, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteGroupPermissions
         * @param {string} authorization Authorization
         * @param {TransactionalDeleteRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupPermissionsUsingPOST: async (authorization: string, request: TransactionalDeleteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('deleteGroupPermissionsUsingPOST', 'authorization', authorization)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('deleteGroupPermissionsUsingPOST', 'request', request)
            const localVarPath = `/transaction/mass_delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary createGroupPermissions
         * @param {string} authorization Authorization
         * @param {Array<TransactionalGroupPermissionRequest>} requests requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroupPermissionsUsingPOST(authorization: string, requests: Array<TransactionalGroupPermissionRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroupPermissionsUsingPOST(authorization, requests, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deleteGroupPermissions
         * @param {string} authorization Authorization
         * @param {TransactionalDeleteRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupPermissionsUsingPOST(authorization: string, request: TransactionalDeleteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupPermissionsUsingPOST(authorization, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * 
         * @summary createGroupPermissions
         * @param {string} authorization Authorization
         * @param {Array<TransactionalGroupPermissionRequest>} requests requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupPermissionsUsingPOST(authorization: string, requests: Array<TransactionalGroupPermissionRequest>, options?: any): AxiosPromise<void> {
            return localVarFp.createGroupPermissionsUsingPOST(authorization, requests, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteGroupPermissions
         * @param {string} authorization Authorization
         * @param {TransactionalDeleteRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupPermissionsUsingPOST(authorization: string, request: TransactionalDeleteRequest, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroupPermissionsUsingPOST(authorization, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * 
     * @summary createGroupPermissions
     * @param {string} authorization Authorization
     * @param {Array<TransactionalGroupPermissionRequest>} requests requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createGroupPermissionsUsingPOST(authorization: string, requests: Array<TransactionalGroupPermissionRequest>, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).createGroupPermissionsUsingPOST(authorization, requests, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteGroupPermissions
     * @param {string} authorization Authorization
     * @param {TransactionalDeleteRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public deleteGroupPermissionsUsingPOST(authorization: string, request: TransactionalDeleteRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).deleteGroupPermissionsUsingPOST(authorization, request, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addApplicationsToUser
         * @param {string} id id
         * @param {Array<string>} applicationIds applicationIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addApplicationsToUserUsingPOST: async (id: string, applicationIds: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addApplicationsToUserUsingPOST', 'id', id)
            // verify required parameter 'applicationIds' is not null or undefined
            assertParamExists('addApplicationsToUserUsingPOST', 'applicationIds', applicationIds)
            const localVarPath = `/users/{id}/applications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationIds, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary addGroupsToUser
         * @param {string} id id
         * @param {Array<string>} groupIds groupIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupsToUserUsingPOST: async (id: string, groupIds: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addGroupsToUserUsingPOST', 'id', id)
            // verify required parameter 'groupIds' is not null or undefined
            assertParamExists('addGroupsToUserUsingPOST', 'groupIds', groupIds)
            const localVarPath = `/users/{id}/groups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupIds, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary addPermissions
         * @param {string} id id
         * @param {Array<PermissionRequest>} permissions permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPermissionsUsingPOST2: async (id: string, permissions: Array<PermissionRequest>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addPermissionsUsingPOST2', 'id', id)
            // verify required parameter 'permissions' is not null or undefined
            assertParamExists('addPermissionsUsingPOST2', 'permissions', permissions)
            const localVarPath = `/users/{id}/permissions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(permissions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteApplicationsFromUser
         * @param {string} applicationIds applicationIds
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationsFromUserUsingDELETE: async (applicationIds: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationIds' is not null or undefined
            assertParamExists('deleteApplicationsFromUserUsingDELETE', 'applicationIds', applicationIds)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteApplicationsFromUserUsingDELETE', 'id', id)
            const localVarPath = `/users/{id}/applications/{applicationIds}`
                .replace(`{${"applicationIds"}}`, encodeURIComponent(String(applicationIds)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteGroupsFromUser
         * @param {string} groupIDs groupIDs
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupsFromUserUsingDELETE: async (groupIDs: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupIDs' is not null or undefined
            assertParamExists('deleteGroupsFromUserUsingDELETE', 'groupIDs', groupIDs)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGroupsFromUserUsingDELETE', 'id', id)
            const localVarPath = `/users/{id}/groups/{groupIDs}`
                .replace(`{${"groupIDs"}}`, encodeURIComponent(String(groupIDs)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deletePermissions
         * @param {string} id id
         * @param {string} permissionIds permissionIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermissionsUsingDELETE2: async (id: string, permissionIds: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePermissionsUsingDELETE2', 'id', id)
            // verify required parameter 'permissionIds' is not null or undefined
            assertParamExists('deletePermissionsUsingDELETE2', 'permissionIds', permissionIds)
            const localVarPath = `/users/{id}/permissions/{permissionIds}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"permissionIds"}}`, encodeURIComponent(String(permissionIds)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteUser
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserUsingDELETE: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUserUsingDELETE', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getApplicationsFromUser
         * @param {string} id Search for ids containing this text
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] query
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationsFromUserUsingGET: async (id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getApplicationsFromUserUsingGET', 'id', id)
            const localVarPath = `/users/{id}/applications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getGroupsFromUser
         * @param {string} id Search for ids containing this text
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] query
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsFromUserUsingGET: async (id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGroupsFromUserUsingGET', 'id', id)
            const localVarPath = `/users/{id}/groups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getPermissions
         * @param {string} id id
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionsUsingGET: async (id: string, limit?: string, offset?: string, sort?: string, sortOrder?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPermissionsUsingGET', 'id', id)
            const localVarPath = `/users/{id}/permissions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getResolvedPermissions
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResolvedPermissionsUsingGET1: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getResolvedPermissionsUsingGET1', 'id', id)
            const localVarPath = `/users/{id}/groups/permissions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUser
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsingGET: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserUsingGET', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listUsers
         * @param {string} [id] Search for ids containing this text
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] Query string compares to Users Email, First Name, and Last Name fields.
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersUsingGET: async (id?: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateUser
         * @param {string} id id
         * @param {UpdateUserRequest} updateUserRequest updateUserRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserUsingPATCH: async (id: string, updateUserRequest: UpdateUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserUsingPATCH', 'id', id)
            // verify required parameter 'updateUserRequest' is not null or undefined
            assertParamExists('updateUserUsingPATCH', 'updateUserRequest', updateUserRequest)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary addApplicationsToUser
         * @param {string} id id
         * @param {Array<string>} applicationIds applicationIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addApplicationsToUserUsingPOST(id: string, applicationIds: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addApplicationsToUserUsingPOST(id, applicationIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary addGroupsToUser
         * @param {string} id id
         * @param {Array<string>} groupIds groupIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addGroupsToUserUsingPOST(id: string, groupIds: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addGroupsToUserUsingPOST(id, groupIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary addPermissions
         * @param {string} id id
         * @param {Array<PermissionRequest>} permissions permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPermissionsUsingPOST2(id: string, permissions: Array<PermissionRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPermissionsUsingPOST2(id, permissions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deleteApplicationsFromUser
         * @param {string} applicationIds applicationIds
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationsFromUserUsingDELETE(applicationIds: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationsFromUserUsingDELETE(applicationIds, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deleteGroupsFromUser
         * @param {string} groupIDs groupIDs
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupsFromUserUsingDELETE(groupIDs: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupsFromUserUsingDELETE(groupIDs, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deletePermissions
         * @param {string} id id
         * @param {string} permissionIds permissionIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePermissionsUsingDELETE2(id: string, permissionIds: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePermissionsUsingDELETE2(id, permissionIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deleteUser
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserUsingDELETE(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserUsingDELETE(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getApplicationsFromUser
         * @param {string} id Search for ids containing this text
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] query
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationsFromUserUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDTOApplication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationsFromUserUsingGET(id, limit, offset, query, sort, sortOrder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getGroupsFromUser
         * @param {string} id Search for ids containing this text
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] query
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupsFromUserUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDTOGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupsFromUserUsingGET(id, limit, offset, query, sort, sortOrder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getPermissions
         * @param {string} id id
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermissionsUsingGET(id: string, limit?: string, offset?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDTOUserPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermissionsUsingGET(id, limit, offset, sort, sortOrder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getResolvedPermissions
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResolvedPermissionsUsingGET1(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResolvedPermissionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResolvedPermissionsUsingGET1(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getUser
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserUsingGET(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserUsingGET(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary listUsers
         * @param {string} [id] Search for ids containing this text
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] Query string compares to Users Email, First Name, and Last Name fields.
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsersUsingGET(id?: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDTOUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsersUsingGET(id, limit, offset, query, sort, sortOrder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updateUser
         * @param {string} id id
         * @param {UpdateUserRequest} updateUserRequest updateUserRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserUsingPATCH(id: string, updateUserRequest: UpdateUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserUsingPATCH(id, updateUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary addApplicationsToUser
         * @param {string} id id
         * @param {Array<string>} applicationIds applicationIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addApplicationsToUserUsingPOST(id: string, applicationIds: Array<string>, options?: any): AxiosPromise<User> {
            return localVarFp.addApplicationsToUserUsingPOST(id, applicationIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary addGroupsToUser
         * @param {string} id id
         * @param {Array<string>} groupIds groupIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupsToUserUsingPOST(id: string, groupIds: Array<string>, options?: any): AxiosPromise<User> {
            return localVarFp.addGroupsToUserUsingPOST(id, groupIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary addPermissions
         * @param {string} id id
         * @param {Array<PermissionRequest>} permissions permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPermissionsUsingPOST2(id: string, permissions: Array<PermissionRequest>, options?: any): AxiosPromise<User> {
            return localVarFp.addPermissionsUsingPOST2(id, permissions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteApplicationsFromUser
         * @param {string} applicationIds applicationIds
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationsFromUserUsingDELETE(applicationIds: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplicationsFromUserUsingDELETE(applicationIds, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteGroupsFromUser
         * @param {string} groupIDs groupIDs
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupsFromUserUsingDELETE(groupIDs: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroupsFromUserUsingDELETE(groupIDs, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deletePermissions
         * @param {string} id id
         * @param {string} permissionIds permissionIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermissionsUsingDELETE2(id: string, permissionIds: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePermissionsUsingDELETE2(id, permissionIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteUser
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserUsingDELETE(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserUsingDELETE(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getApplicationsFromUser
         * @param {string} id Search for ids containing this text
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] query
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationsFromUserUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: any): AxiosPromise<PageDTOApplication> {
            return localVarFp.getApplicationsFromUserUsingGET(id, limit, offset, query, sort, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getGroupsFromUser
         * @param {string} id Search for ids containing this text
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] query
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsFromUserUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: any): AxiosPromise<PageDTOGroup> {
            return localVarFp.getGroupsFromUserUsingGET(id, limit, offset, query, sort, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getPermissions
         * @param {string} id id
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionsUsingGET(id: string, limit?: string, offset?: string, sort?: string, sortOrder?: string, options?: any): AxiosPromise<PageDTOUserPermission> {
            return localVarFp.getPermissionsUsingGET(id, limit, offset, sort, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getResolvedPermissions
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResolvedPermissionsUsingGET1(id: string, options?: any): AxiosPromise<Array<ResolvedPermissionResponse>> {
            return localVarFp.getResolvedPermissionsUsingGET1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getUser
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsingGET(id: string, options?: any): AxiosPromise<User> {
            return localVarFp.getUserUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary listUsers
         * @param {string} [id] Search for ids containing this text
         * @param {string} [limit] Number of results to retrieve
         * @param {string} [offset] Index of first result to retrieve
         * @param {string} [query] Query string compares to Users Email, First Name, and Last Name fields.
         * @param {string} [sort] Field to sort on
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersUsingGET(id?: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: any): AxiosPromise<PageDTOUser> {
            return localVarFp.listUsersUsingGET(id, limit, offset, query, sort, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateUser
         * @param {string} id id
         * @param {UpdateUserRequest} updateUserRequest updateUserRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserUsingPATCH(id: string, updateUserRequest: UpdateUserRequest, options?: any): AxiosPromise<User> {
            return localVarFp.updateUserUsingPATCH(id, updateUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary addApplicationsToUser
     * @param {string} id id
     * @param {Array<string>} applicationIds applicationIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public addApplicationsToUserUsingPOST(id: string, applicationIds: Array<string>, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).addApplicationsToUserUsingPOST(id, applicationIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary addGroupsToUser
     * @param {string} id id
     * @param {Array<string>} groupIds groupIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public addGroupsToUserUsingPOST(id: string, groupIds: Array<string>, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).addGroupsToUserUsingPOST(id, groupIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary addPermissions
     * @param {string} id id
     * @param {Array<PermissionRequest>} permissions permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public addPermissionsUsingPOST2(id: string, permissions: Array<PermissionRequest>, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).addPermissionsUsingPOST2(id, permissions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteApplicationsFromUser
     * @param {string} applicationIds applicationIds
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteApplicationsFromUserUsingDELETE(applicationIds: string, id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteApplicationsFromUserUsingDELETE(applicationIds, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteGroupsFromUser
     * @param {string} groupIDs groupIDs
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteGroupsFromUserUsingDELETE(groupIDs: string, id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteGroupsFromUserUsingDELETE(groupIDs, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deletePermissions
     * @param {string} id id
     * @param {string} permissionIds permissionIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deletePermissionsUsingDELETE2(id: string, permissionIds: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deletePermissionsUsingDELETE2(id, permissionIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteUser
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUserUsingDELETE(id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUserUsingDELETE(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getApplicationsFromUser
     * @param {string} id Search for ids containing this text
     * @param {string} [limit] Number of results to retrieve
     * @param {string} [offset] Index of first result to retrieve
     * @param {string} [query] query
     * @param {string} [sort] Field to sort on
     * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getApplicationsFromUserUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getApplicationsFromUserUsingGET(id, limit, offset, query, sort, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getGroupsFromUser
     * @param {string} id Search for ids containing this text
     * @param {string} [limit] Number of results to retrieve
     * @param {string} [offset] Index of first result to retrieve
     * @param {string} [query] query
     * @param {string} [sort] Field to sort on
     * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getGroupsFromUserUsingGET(id: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getGroupsFromUserUsingGET(id, limit, offset, query, sort, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getPermissions
     * @param {string} id id
     * @param {string} [limit] Number of results to retrieve
     * @param {string} [offset] Index of first result to retrieve
     * @param {string} [sort] Field to sort on
     * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getPermissionsUsingGET(id: string, limit?: string, offset?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getPermissionsUsingGET(id, limit, offset, sort, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getResolvedPermissions
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getResolvedPermissionsUsingGET1(id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getResolvedPermissionsUsingGET1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getUser
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserUsingGET(id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary listUsers
     * @param {string} [id] Search for ids containing this text
     * @param {string} [limit] Number of results to retrieve
     * @param {string} [offset] Index of first result to retrieve
     * @param {string} [query] Query string compares to Users Email, First Name, and Last Name fields.
     * @param {string} [sort] Field to sort on
     * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUsersUsingGET(id?: string, limit?: string, offset?: string, query?: string, sort?: string, sortOrder?: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listUsersUsingGET(id, limit, offset, query, sort, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateUser
     * @param {string} id id
     * @param {UpdateUserRequest} updateUserRequest updateUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserUsingPATCH(id: string, updateUserRequest: UpdateUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserUsingPATCH(id, updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


