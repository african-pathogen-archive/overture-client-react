/* tslint:disable */
/* eslint-disable */
/**
 * Song API
 * Song API reference for developers. SONG is an open source system for validating and tracking metadata about raw data submissions, assigning identifiers to entities of interest, and managing the state of the raw data with regards to publication and access
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Analysis
 */
export interface Analysis {
    /**
     * 
     * @type {string}
     * @memberof Analysis
     */
    'analysisId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Analysis
     */
    'analysisState'?: string;
    /**
     * 
     * @type {Array<AnalysisStateChange>}
     * @memberof Analysis
     */
    'analysisStateHistory'?: Array<AnalysisStateChange>;
    /**
     * 
     * @type {AnalysisTypeId}
     * @memberof Analysis
     */
    'analysisType'?: AnalysisTypeId;
    /**
     * 
     * @type {string}
     * @memberof Analysis
     */
    'createdAt'?: string;
    /**
     * 
     * @type {Array<FileEntity>}
     * @memberof Analysis
     */
    'files'?: Array<FileEntity>;
    /**
     * 
     * @type {string}
     * @memberof Analysis
     */
    'firstPublishedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Analysis
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {Array<CompositeEntity>}
     * @memberof Analysis
     */
    'samples'?: Array<CompositeEntity>;
    /**
     * 
     * @type {string}
     * @memberof Analysis
     */
    'studyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Analysis
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface AnalysisStateChange
 */
export interface AnalysisStateChange {
    /**
     * 
     * @type {string}
     * @memberof AnalysisStateChange
     */
    'initialState'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnalysisStateChange
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnalysisStateChange
     */
    'updatedState'?: string;
}
/**
 * 
 * @export
 * @interface AnalysisType
 */
export interface AnalysisType {
    /**
     * 
     * @type {string}
     * @memberof AnalysisType
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnalysisType
     */
    'name'?: string;
    /**
     * 
     * @type {JsonNode}
     * @memberof AnalysisType
     */
    'schema'?: JsonNode;
    /**
     * 
     * @type {number}
     * @memberof AnalysisType
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface AnalysisTypeId
 */
export interface AnalysisTypeId {
    /**
     * 
     * @type {string}
     * @memberof AnalysisTypeId
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof AnalysisTypeId
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface CompositeEntity
 */
export interface CompositeEntity {
    /**
     * 
     * @type {Donor}
     * @memberof CompositeEntity
     */
    'donor'?: Donor;
    /**
     * 
     * @type {JsonNode}
     * @memberof CompositeEntity
     */
    'info'?: JsonNode;
    /**
     * 
     * @type {string}
     * @memberof CompositeEntity
     */
    'matchedNormalSubmitterSampleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CompositeEntity
     */
    'sampleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CompositeEntity
     */
    'sampleType'?: string;
    /**
     * 
     * @type {Specimen}
     * @memberof CompositeEntity
     */
    'specimen'?: Specimen;
    /**
     * 
     * @type {string}
     * @memberof CompositeEntity
     */
    'specimenId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CompositeEntity
     */
    'submitterSampleId'?: string;
}
/**
 * 
 * @export
 * @interface Donor
 */
export interface Donor {
    /**
     * 
     * @type {string}
     * @memberof Donor
     */
    'donorId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Donor
     */
    'gender'?: string;
    /**
     * 
     * @type {JsonNode}
     * @memberof Donor
     */
    'info'?: JsonNode;
    /**
     * 
     * @type {string}
     * @memberof Donor
     */
    'studyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Donor
     */
    'submitterDonorId'?: string;
}
/**
 * 
 * @export
 * @interface DonorWithSpecimens
 */
export interface DonorWithSpecimens {
    /**
     * 
     * @type {string}
     * @memberof DonorWithSpecimens
     */
    'donorId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DonorWithSpecimens
     */
    'gender'?: string;
    /**
     * 
     * @type {JsonNode}
     * @memberof DonorWithSpecimens
     */
    'info'?: JsonNode;
    /**
     * 
     * @type {Array<SpecimenWithSamples>}
     * @memberof DonorWithSpecimens
     */
    'specimens'?: Array<SpecimenWithSamples>;
    /**
     * 
     * @type {string}
     * @memberof DonorWithSpecimens
     */
    'studyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DonorWithSpecimens
     */
    'submitterDonorId'?: string;
}
/**
 * 
 * @export
 * @interface ExportedPayload
 */
export interface ExportedPayload {
    /**
     * 
     * @type {Array<JsonNode>}
     * @memberof ExportedPayload
     */
    'payloads'?: Array<JsonNode>;
    /**
     * 
     * @type {string}
     * @memberof ExportedPayload
     */
    'studyId'?: string;
}
/**
 * 
 * @export
 * @interface FileDTO
 */
export interface FileDTO {
    /**
     * 
     * @type {string}
     * @memberof FileDTO
     */
    'analysisId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileDTO
     */
    'dataType'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileDTO
     */
    'fileAccess'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileDTO
     */
    'fileMd5sum'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileDTO
     */
    'fileName'?: string;
    /**
     * 
     * @type {number}
     * @memberof FileDTO
     */
    'fileSize'?: number;
    /**
     * 
     * @type {string}
     * @memberof FileDTO
     */
    'fileType'?: string;
    /**
     * 
     * @type {JsonNode}
     * @memberof FileDTO
     */
    'info'?: JsonNode;
    /**
     * 
     * @type {string}
     * @memberof FileDTO
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileDTO
     */
    'studyId'?: string;
}
/**
 * 
 * @export
 * @interface FileEntity
 */
export interface FileEntity {
    /**
     * 
     * @type {string}
     * @memberof FileEntity
     */
    'analysisId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileEntity
     */
    'dataType'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileEntity
     */
    'fileAccess'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileEntity
     */
    'fileMd5sum'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileEntity
     */
    'fileName'?: string;
    /**
     * 
     * @type {number}
     * @memberof FileEntity
     */
    'fileSize'?: number;
    /**
     * 
     * @type {string}
     * @memberof FileEntity
     */
    'fileType'?: string;
    /**
     * 
     * @type {JsonNode}
     * @memberof FileEntity
     */
    'info'?: JsonNode;
    /**
     * 
     * @type {string}
     * @memberof FileEntity
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileEntity
     */
    'studyId'?: string;
}
/**
 * 
 * @export
 * @interface FileUpdateRequest
 */
export interface FileUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof FileUpdateRequest
     */
    'dataType'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileUpdateRequest
     */
    'fileAccess'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileUpdateRequest
     */
    'fileMd5sum'?: string;
    /**
     * 
     * @type {number}
     * @memberof FileUpdateRequest
     */
    'fileSize'?: number;
    /**
     * 
     * @type {JsonNode}
     * @memberof FileUpdateRequest
     */
    'info'?: JsonNode;
}
/**
 * 
 * @export
 * @interface FileUpdateResponse
 */
export interface FileUpdateResponse {
    /**
     * 
     * @type {string}
     * @memberof FileUpdateResponse
     */
    'fileUpdateType'?: FileUpdateResponseFileUpdateTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof FileUpdateResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileUpdateResponse
     */
    'originalAnalysisState'?: FileUpdateResponseOriginalAnalysisStateEnum;
    /**
     * 
     * @type {FileDTO}
     * @memberof FileUpdateResponse
     */
    'originalFile'?: FileDTO;
    /**
     * 
     * @type {boolean}
     * @memberof FileUpdateResponse
     */
    'unpublishedAnalysis'?: boolean;
}

export const FileUpdateResponseFileUpdateTypeEnum = {
    NoUpdate: 'NO_UPDATE',
    ContentUpdate: 'CONTENT_UPDATE',
    MetadataUpdate: 'METADATA_UPDATE'
} as const;

export type FileUpdateResponseFileUpdateTypeEnum = typeof FileUpdateResponseFileUpdateTypeEnum[keyof typeof FileUpdateResponseFileUpdateTypeEnum];
export const FileUpdateResponseOriginalAnalysisStateEnum = {
    Published: 'PUBLISHED',
    Unpublished: 'UNPUBLISHED',
    Suppressed: 'SUPPRESSED'
} as const;

export type FileUpdateResponseOriginalAnalysisStateEnum = typeof FileUpdateResponseOriginalAnalysisStateEnum[keyof typeof FileUpdateResponseOriginalAnalysisStateEnum];

/**
 * 
 * @export
 * @interface GenericMessage
 */
export interface GenericMessage {
    /**
     * 
     * @type {string}
     * @memberof GenericMessage
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface IdSearchRequest
 */
export interface IdSearchRequest {
    /**
     * regex pattern. Default is wildcard
     * @type {string}
     * @memberof IdSearchRequest
     */
    'donorId'?: string;
    /**
     * regex pattern. Default is wildcard
     * @type {string}
     * @memberof IdSearchRequest
     */
    'objectId'?: string;
    /**
     * regex pattern. Default is wildcard
     * @type {string}
     * @memberof IdSearchRequest
     */
    'sampleId'?: string;
    /**
     * regex pattern. Default is wildcard
     * @type {string}
     * @memberof IdSearchRequest
     */
    'specimenId'?: string;
}
/**
 * 
 * @export
 * @interface JsonNode
 */
export interface JsonNode {
    /**
     * 
     * @type {boolean}
     * @memberof JsonNode
     */
    'array'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JsonNode
     */
    'bigDecimal'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JsonNode
     */
    'bigInteger'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JsonNode
     */
    'binary'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JsonNode
     */
    'boolean'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JsonNode
     */
    'containerNode'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JsonNode
     */
    'double'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JsonNode
     */
    'float'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JsonNode
     */
    'floatingPointNumber'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JsonNode
     */
    'int'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JsonNode
     */
    'integralNumber'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JsonNode
     */
    'long'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JsonNode
     */
    'missingNode'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof JsonNode
     */
    'nodeType'?: JsonNodeNodeTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof JsonNode
     */
    'null'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JsonNode
     */
    'number'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JsonNode
     */
    'object'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JsonNode
     */
    'pojo'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JsonNode
     */
    'short'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JsonNode
     */
    'textual'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JsonNode
     */
    'valueNode'?: boolean;
}

export const JsonNodeNodeTypeEnum = {
    Array: 'ARRAY',
    Binary: 'BINARY',
    Boolean: 'BOOLEAN',
    Missing: 'MISSING',
    Null: 'NULL',
    Number: 'NUMBER',
    Object: 'OBJECT',
    Pojo: 'POJO',
    String: 'STRING'
} as const;

export type JsonNodeNodeTypeEnum = typeof JsonNodeNodeTypeEnum[keyof typeof JsonNodeNodeTypeEnum];

/**
 * 
 * @export
 * @interface Legacy
 */
export interface Legacy {
    /**
     * 
     * @type {string}
     * @memberof Legacy
     */
    'access'?: string;
    /**
     * 
     * @type {string}
     * @memberof Legacy
     */
    'fileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Legacy
     */
    'gnosId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Legacy
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Legacy
     */
    'projectCode'?: string;
}
/**
 * 
 * @export
 * @interface PageDTOAnalysisType
 */
export interface PageDTOAnalysisType {
    /**
     * 
     * @type {number}
     * @memberof PageDTOAnalysisType
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDTOAnalysisType
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDTOAnalysisType
     */
    'offset'?: number;
    /**
     * 
     * @type {Array<AnalysisType>}
     * @memberof PageDTOAnalysisType
     */
    'resultSet'?: Array<AnalysisType>;
}
/**
 * 
 * @export
 * @interface RegisterAnalysisTypeRequest
 */
export interface RegisterAnalysisTypeRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterAnalysisTypeRequest
     */
    'name'?: string;
    /**
     * 
     * @type {JsonNode}
     * @memberof RegisterAnalysisTypeRequest
     */
    'schema'?: JsonNode;
}
/**
 * 
 * @export
 * @interface Sample
 */
export interface Sample {
    /**
     * 
     * @type {JsonNode}
     * @memberof Sample
     */
    'info'?: JsonNode;
    /**
     * 
     * @type {string}
     * @memberof Sample
     */
    'matchedNormalSubmitterSampleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sample
     */
    'sampleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sample
     */
    'sampleType'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sample
     */
    'specimenId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sample
     */
    'submitterSampleId'?: string;
}
/**
 * 
 * @export
 * @interface Specimen
 */
export interface Specimen {
    /**
     * 
     * @type {string}
     * @memberof Specimen
     */
    'donorId'?: string;
    /**
     * 
     * @type {JsonNode}
     * @memberof Specimen
     */
    'info'?: JsonNode;
    /**
     * 
     * @type {string}
     * @memberof Specimen
     */
    'specimenId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Specimen
     */
    'specimenTissueSource'?: string;
    /**
     * 
     * @type {string}
     * @memberof Specimen
     */
    'specimenType'?: string;
    /**
     * 
     * @type {string}
     * @memberof Specimen
     */
    'submitterSpecimenId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Specimen
     */
    'tumourNormalDesignation'?: string;
}
/**
 * 
 * @export
 * @interface SpecimenWithSamples
 */
export interface SpecimenWithSamples {
    /**
     * 
     * @type {string}
     * @memberof SpecimenWithSamples
     */
    'donorId'?: string;
    /**
     * 
     * @type {JsonNode}
     * @memberof SpecimenWithSamples
     */
    'info'?: JsonNode;
    /**
     * 
     * @type {Array<Sample>}
     * @memberof SpecimenWithSamples
     */
    'samples'?: Array<Sample>;
    /**
     * 
     * @type {Specimen}
     * @memberof SpecimenWithSamples
     */
    'specimen'?: Specimen;
    /**
     * 
     * @type {string}
     * @memberof SpecimenWithSamples
     */
    'specimenId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpecimenWithSamples
     */
    'specimenTissueSource'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpecimenWithSamples
     */
    'specimenType'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpecimenWithSamples
     */
    'submitterSpecimenId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpecimenWithSamples
     */
    'tumourNormalDesignation'?: string;
}
/**
 * 
 * @export
 * @interface Study
 */
export interface Study {
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'description'?: string;
    /**
     * 
     * @type {JsonNode}
     * @memberof Study
     */
    'info'?: JsonNode;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'organization'?: string;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'studyId'?: string;
}
/**
 * 
 * @export
 * @interface StudyWithDonors
 */
export interface StudyWithDonors {
    /**
     * 
     * @type {string}
     * @memberof StudyWithDonors
     */
    'description'?: string;
    /**
     * 
     * @type {Array<DonorWithSpecimens>}
     * @memberof StudyWithDonors
     */
    'donors'?: Array<DonorWithSpecimens>;
    /**
     * 
     * @type {JsonNode}
     * @memberof StudyWithDonors
     */
    'info'?: JsonNode;
    /**
     * 
     * @type {string}
     * @memberof StudyWithDonors
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudyWithDonors
     */
    'organization'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudyWithDonors
     */
    'studyId'?: string;
}
/**
 * 
 * @export
 * @interface SubmitResponse
 */
export interface SubmitResponse {
    /**
     * 
     * @type {string}
     * @memberof SubmitResponse
     */
    'analysisId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubmitResponse
     */
    'status'?: string;
}

/**
 * AnalysisApi - axios parameter creator
 * @export
 */
export const AnalysisApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all analysis objects for a studyId
         * @summary GetAnalysesForStudy
         * @param {string} studyId studyId
         * @param {string} [analysisStates] Non-empty comma separated list of analysis states to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisUsingGET: async (studyId: string, analysisStates?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('getAnalysisUsingGET', 'studyId', studyId)
            const localVarPath = `/studies/{studyId}/analysis`
                .replace(`{${"studyId"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (analysisStates !== undefined) {
                localVarQueryParameter['analysisStates'] = analysisStates;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the file objects for an analysisId
         * @summary ReadAnalysisFiles
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilesByIdUsingGET: async (id: string, studyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFilesByIdUsingGET', 'id', id)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('getFilesByIdUsingGET', 'studyId', studyId)
            const localVarPath = `/studies/{studyId}/analysis/{id}/files`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"studyId"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for analysis objects by specifying regex patterns for the donorIds, sampleIds, specimenIds, or fileIds request parameters
         * @summary IdSearch
         * @param {string} studyId studyId
         * @param {string} [donorId] donorId
         * @param {string} [fileId] fileId
         * @param {string} [sampleId] sampleId
         * @param {string} [specimenId] specimenId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idSearchUsingGET: async (studyId: string, donorId?: string, fileId?: string, sampleId?: string, specimenId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('idSearchUsingGET', 'studyId', studyId)
            const localVarPath = `/studies/{studyId}/analysis/search/id`
                .replace(`{${"studyId"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (donorId !== undefined) {
                localVarQueryParameter['donorId'] = donorId;
            }

            if (fileId !== undefined) {
                localVarQueryParameter['fileId'] = fileId;
            }

            if (sampleId !== undefined) {
                localVarQueryParameter['sampleId'] = sampleId;
            }

            if (specimenId !== undefined) {
                localVarQueryParameter['specimenId'] = specimenId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for analysis objects by specifying an IdSearchRequest
         * @summary IdSearch
         * @param {string} studyId studyId
         * @param {IdSearchRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idSearchUsingPOST: async (studyId: string, request: IdSearchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('idSearchUsingPOST', 'studyId', studyId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('idSearchUsingPOST', 'request', request)
            const localVarPath = `/studies/{studyId}/analysis/search/id`
                .replace(`{${"studyId"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Publish an analysis. This checks to see if the files associated with the input analysisId exist in the storage server
         * @summary PublishAnalysis
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {string} [authorization] Authorization
         * @param {boolean} [ignoreUndefinedMd5] Ignores files that have an undefined MD5 checksum when publishing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishAnalysisUsingPUT: async (id: string, studyId: string, authorization?: string, ignoreUndefinedMd5?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('publishAnalysisUsingPUT', 'id', id)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('publishAnalysisUsingPUT', 'studyId', studyId)
            const localVarPath = `/studies/{studyId}/analysis/publish/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"studyId"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ignoreUndefinedMd5 !== undefined) {
                localVarQueryParameter['ignoreUndefinedMd5'] = ignoreUndefinedMd5;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the analysis object for an analysisId
         * @summary ReadAnalysis
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsingGET: async (id: string, studyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readUsingGET', 'id', id)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('readUsingGET', 'studyId', studyId)
            const localVarPath = `/studies/{studyId}/analysis/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"studyId"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Suppress an analysis. Used if a previously published analysis is no longer needed. Instead of removing the analysis, it is marked as \"suppressed\"
         * @summary SuppressAnalysis
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suppressAnalysisUsingPUT: async (id: string, studyId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('suppressAnalysisUsingPUT', 'id', id)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('suppressAnalysisUsingPUT', 'studyId', studyId)
            const localVarPath = `/studies/{studyId}/analysis/suppress/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"studyId"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unpublish an analysis. Set the analysis status to unpublished
         * @summary UnpublishAnalysis
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublishAnalysisUsingPUT: async (id: string, studyId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unpublishAnalysisUsingPUT', 'id', id)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('unpublishAnalysisUsingPUT', 'studyId', studyId)
            const localVarPath = `/studies/{studyId}/analysis/unpublish/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"studyId"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update dynamic-data for for an analysis
         * @summary UpdateAnalysis
         * @param {string} analysisId analysisId
         * @param {string} studyId studyId
         * @param {JsonNode} updateAnalysisRequest updateAnalysisRequest
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnalysisUsingPUT: async (analysisId: string, studyId: string, updateAnalysisRequest: JsonNode, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'analysisId' is not null or undefined
            assertParamExists('updateAnalysisUsingPUT', 'analysisId', analysisId)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('updateAnalysisUsingPUT', 'studyId', studyId)
            // verify required parameter 'updateAnalysisRequest' is not null or undefined
            assertParamExists('updateAnalysisUsingPUT', 'updateAnalysisRequest', updateAnalysisRequest)
            const localVarPath = `/studies/{studyId}/analysis/{analysisId}`
                .replace(`{${"analysisId"}}`, encodeURIComponent(String(analysisId)))
                .replace(`{${"studyId"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAnalysisRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalysisApi - functional programming interface
 * @export
 */
export const AnalysisApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalysisApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all analysis objects for a studyId
         * @summary GetAnalysesForStudy
         * @param {string} studyId studyId
         * @param {string} [analysisStates] Non-empty comma separated list of analysis states to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnalysisUsingGET(studyId: string, analysisStates?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Analysis>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnalysisUsingGET(studyId, analysisStates, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the file objects for an analysisId
         * @summary ReadAnalysisFiles
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilesByIdUsingGET(id: string, studyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilesByIdUsingGET(id, studyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search for analysis objects by specifying regex patterns for the donorIds, sampleIds, specimenIds, or fileIds request parameters
         * @summary IdSearch
         * @param {string} studyId studyId
         * @param {string} [donorId] donorId
         * @param {string} [fileId] fileId
         * @param {string} [sampleId] sampleId
         * @param {string} [specimenId] specimenId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idSearchUsingGET(studyId: string, donorId?: string, fileId?: string, sampleId?: string, specimenId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Analysis>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idSearchUsingGET(studyId, donorId, fileId, sampleId, specimenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search for analysis objects by specifying an IdSearchRequest
         * @summary IdSearch
         * @param {string} studyId studyId
         * @param {IdSearchRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idSearchUsingPOST(studyId: string, request: IdSearchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Analysis>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idSearchUsingPOST(studyId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Publish an analysis. This checks to see if the files associated with the input analysisId exist in the storage server
         * @summary PublishAnalysis
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {string} [authorization] Authorization
         * @param {boolean} [ignoreUndefinedMd5] Ignores files that have an undefined MD5 checksum when publishing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishAnalysisUsingPUT(id: string, studyId: string, authorization?: string, ignoreUndefinedMd5?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishAnalysisUsingPUT(id, studyId, authorization, ignoreUndefinedMd5, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the analysis object for an analysisId
         * @summary ReadAnalysis
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUsingGET(id: string, studyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Analysis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUsingGET(id, studyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Suppress an analysis. Used if a previously published analysis is no longer needed. Instead of removing the analysis, it is marked as \"suppressed\"
         * @summary SuppressAnalysis
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async suppressAnalysisUsingPUT(id: string, studyId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.suppressAnalysisUsingPUT(id, studyId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unpublish an analysis. Set the analysis status to unpublished
         * @summary UnpublishAnalysis
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unpublishAnalysisUsingPUT(id: string, studyId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unpublishAnalysisUsingPUT(id, studyId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update dynamic-data for for an analysis
         * @summary UpdateAnalysis
         * @param {string} analysisId analysisId
         * @param {string} studyId studyId
         * @param {JsonNode} updateAnalysisRequest updateAnalysisRequest
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAnalysisUsingPUT(analysisId: string, studyId: string, updateAnalysisRequest: JsonNode, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAnalysisUsingPUT(analysisId, studyId, updateAnalysisRequest, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AnalysisApi - factory interface
 * @export
 */
export const AnalysisApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalysisApiFp(configuration)
    return {
        /**
         * Retrieve all analysis objects for a studyId
         * @summary GetAnalysesForStudy
         * @param {string} studyId studyId
         * @param {string} [analysisStates] Non-empty comma separated list of analysis states to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisUsingGET(studyId: string, analysisStates?: string, options?: any): AxiosPromise<Array<Analysis>> {
            return localVarFp.getAnalysisUsingGET(studyId, analysisStates, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the file objects for an analysisId
         * @summary ReadAnalysisFiles
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilesByIdUsingGET(id: string, studyId: string, options?: any): AxiosPromise<Array<FileEntity>> {
            return localVarFp.getFilesByIdUsingGET(id, studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for analysis objects by specifying regex patterns for the donorIds, sampleIds, specimenIds, or fileIds request parameters
         * @summary IdSearch
         * @param {string} studyId studyId
         * @param {string} [donorId] donorId
         * @param {string} [fileId] fileId
         * @param {string} [sampleId] sampleId
         * @param {string} [specimenId] specimenId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idSearchUsingGET(studyId: string, donorId?: string, fileId?: string, sampleId?: string, specimenId?: string, options?: any): AxiosPromise<Array<Analysis>> {
            return localVarFp.idSearchUsingGET(studyId, donorId, fileId, sampleId, specimenId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for analysis objects by specifying an IdSearchRequest
         * @summary IdSearch
         * @param {string} studyId studyId
         * @param {IdSearchRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idSearchUsingPOST(studyId: string, request: IdSearchRequest, options?: any): AxiosPromise<Array<Analysis>> {
            return localVarFp.idSearchUsingPOST(studyId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Publish an analysis. This checks to see if the files associated with the input analysisId exist in the storage server
         * @summary PublishAnalysis
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {string} [authorization] Authorization
         * @param {boolean} [ignoreUndefinedMd5] Ignores files that have an undefined MD5 checksum when publishing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishAnalysisUsingPUT(id: string, studyId: string, authorization?: string, ignoreUndefinedMd5?: boolean, options?: any): AxiosPromise<string> {
            return localVarFp.publishAnalysisUsingPUT(id, studyId, authorization, ignoreUndefinedMd5, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the analysis object for an analysisId
         * @summary ReadAnalysis
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsingGET(id: string, studyId: string, options?: any): AxiosPromise<Analysis> {
            return localVarFp.readUsingGET(id, studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Suppress an analysis. Used if a previously published analysis is no longer needed. Instead of removing the analysis, it is marked as \"suppressed\"
         * @summary SuppressAnalysis
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suppressAnalysisUsingPUT(id: string, studyId: string, authorization?: string, options?: any): AxiosPromise<string> {
            return localVarFp.suppressAnalysisUsingPUT(id, studyId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Unpublish an analysis. Set the analysis status to unpublished
         * @summary UnpublishAnalysis
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublishAnalysisUsingPUT(id: string, studyId: string, authorization?: string, options?: any): AxiosPromise<string> {
            return localVarFp.unpublishAnalysisUsingPUT(id, studyId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Update dynamic-data for for an analysis
         * @summary UpdateAnalysis
         * @param {string} analysisId analysisId
         * @param {string} studyId studyId
         * @param {JsonNode} updateAnalysisRequest updateAnalysisRequest
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnalysisUsingPUT(analysisId: string, studyId: string, updateAnalysisRequest: JsonNode, authorization?: string, options?: any): AxiosPromise<void> {
            return localVarFp.updateAnalysisUsingPUT(analysisId, studyId, updateAnalysisRequest, authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalysisApi - object-oriented interface
 * @export
 * @class AnalysisApi
 * @extends {BaseAPI}
 */
export class AnalysisApi extends BaseAPI {
    /**
     * Retrieve all analysis objects for a studyId
     * @summary GetAnalysesForStudy
     * @param {string} studyId studyId
     * @param {string} [analysisStates] Non-empty comma separated list of analysis states to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysisApi
     */
    public getAnalysisUsingGET(studyId: string, analysisStates?: string, options?: AxiosRequestConfig) {
        return AnalysisApiFp(this.configuration).getAnalysisUsingGET(studyId, analysisStates, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the file objects for an analysisId
     * @summary ReadAnalysisFiles
     * @param {string} id id
     * @param {string} studyId studyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysisApi
     */
    public getFilesByIdUsingGET(id: string, studyId: string, options?: AxiosRequestConfig) {
        return AnalysisApiFp(this.configuration).getFilesByIdUsingGET(id, studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for analysis objects by specifying regex patterns for the donorIds, sampleIds, specimenIds, or fileIds request parameters
     * @summary IdSearch
     * @param {string} studyId studyId
     * @param {string} [donorId] donorId
     * @param {string} [fileId] fileId
     * @param {string} [sampleId] sampleId
     * @param {string} [specimenId] specimenId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysisApi
     */
    public idSearchUsingGET(studyId: string, donorId?: string, fileId?: string, sampleId?: string, specimenId?: string, options?: AxiosRequestConfig) {
        return AnalysisApiFp(this.configuration).idSearchUsingGET(studyId, donorId, fileId, sampleId, specimenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for analysis objects by specifying an IdSearchRequest
     * @summary IdSearch
     * @param {string} studyId studyId
     * @param {IdSearchRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysisApi
     */
    public idSearchUsingPOST(studyId: string, request: IdSearchRequest, options?: AxiosRequestConfig) {
        return AnalysisApiFp(this.configuration).idSearchUsingPOST(studyId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Publish an analysis. This checks to see if the files associated with the input analysisId exist in the storage server
     * @summary PublishAnalysis
     * @param {string} id id
     * @param {string} studyId studyId
     * @param {string} [authorization] Authorization
     * @param {boolean} [ignoreUndefinedMd5] Ignores files that have an undefined MD5 checksum when publishing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysisApi
     */
    public publishAnalysisUsingPUT(id: string, studyId: string, authorization?: string, ignoreUndefinedMd5?: boolean, options?: AxiosRequestConfig) {
        return AnalysisApiFp(this.configuration).publishAnalysisUsingPUT(id, studyId, authorization, ignoreUndefinedMd5, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the analysis object for an analysisId
     * @summary ReadAnalysis
     * @param {string} id id
     * @param {string} studyId studyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysisApi
     */
    public readUsingGET(id: string, studyId: string, options?: AxiosRequestConfig) {
        return AnalysisApiFp(this.configuration).readUsingGET(id, studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Suppress an analysis. Used if a previously published analysis is no longer needed. Instead of removing the analysis, it is marked as \"suppressed\"
     * @summary SuppressAnalysis
     * @param {string} id id
     * @param {string} studyId studyId
     * @param {string} [authorization] Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysisApi
     */
    public suppressAnalysisUsingPUT(id: string, studyId: string, authorization?: string, options?: AxiosRequestConfig) {
        return AnalysisApiFp(this.configuration).suppressAnalysisUsingPUT(id, studyId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unpublish an analysis. Set the analysis status to unpublished
     * @summary UnpublishAnalysis
     * @param {string} id id
     * @param {string} studyId studyId
     * @param {string} [authorization] Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysisApi
     */
    public unpublishAnalysisUsingPUT(id: string, studyId: string, authorization?: string, options?: AxiosRequestConfig) {
        return AnalysisApiFp(this.configuration).unpublishAnalysisUsingPUT(id, studyId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update dynamic-data for for an analysis
     * @summary UpdateAnalysis
     * @param {string} analysisId analysisId
     * @param {string} studyId studyId
     * @param {JsonNode} updateAnalysisRequest updateAnalysisRequest
     * @param {string} [authorization] Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysisApi
     */
    public updateAnalysisUsingPUT(analysisId: string, studyId: string, updateAnalysisRequest: JsonNode, authorization?: string, options?: AxiosRequestConfig) {
        return AnalysisApiFp(this.configuration).updateAnalysisUsingPUT(analysisId, studyId, updateAnalysisRequest, authorization, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DonorApi - axios parameter creator
 * @export
 */
export const DonorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes donor data and all dependent specimens and samples for donorIds
         * @summary DeleteDonors
         * @param {string} ids Comma separated list of donorIds
         * @param {string} studyId studyId
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsingDELETE: async (ids: string, studyId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteUsingDELETE', 'ids', ids)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('deleteUsingDELETE', 'studyId', studyId)
            const localVarPath = `/studies/{studyId}/donors/{ids}`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids)))
                .replace(`{${"studyId"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves donor data for a donorId
         * @summary ReadDonor
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsingGET1: async (id: string, studyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readUsingGET1', 'id', id)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('readUsingGET1', 'studyId', studyId)
            const localVarPath = `/studies/{studyId}/donors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"studyId"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DonorApi - functional programming interface
 * @export
 */
export const DonorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DonorApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes donor data and all dependent specimens and samples for donorIds
         * @summary DeleteDonors
         * @param {string} ids Comma separated list of donorIds
         * @param {string} studyId studyId
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsingDELETE(ids: string, studyId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUsingDELETE(ids, studyId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves donor data for a donorId
         * @summary ReadDonor
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUsingGET1(id: string, studyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Donor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUsingGET1(id, studyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DonorApi - factory interface
 * @export
 */
export const DonorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DonorApiFp(configuration)
    return {
        /**
         * Deletes donor data and all dependent specimens and samples for donorIds
         * @summary DeleteDonors
         * @param {string} ids Comma separated list of donorIds
         * @param {string} studyId studyId
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsingDELETE(ids: string, studyId: string, authorization?: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteUsingDELETE(ids, studyId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves donor data for a donorId
         * @summary ReadDonor
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsingGET1(id: string, studyId: string, options?: any): AxiosPromise<Donor> {
            return localVarFp.readUsingGET1(id, studyId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DonorApi - object-oriented interface
 * @export
 * @class DonorApi
 * @extends {BaseAPI}
 */
export class DonorApi extends BaseAPI {
    /**
     * Deletes donor data and all dependent specimens and samples for donorIds
     * @summary DeleteDonors
     * @param {string} ids Comma separated list of donorIds
     * @param {string} studyId studyId
     * @param {string} [authorization] Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DonorApi
     */
    public deleteUsingDELETE(ids: string, studyId: string, authorization?: string, options?: AxiosRequestConfig) {
        return DonorApiFp(this.configuration).deleteUsingDELETE(ids, studyId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves donor data for a donorId
     * @summary ReadDonor
     * @param {string} id id
     * @param {string} studyId studyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DonorApi
     */
    public readUsingGET1(id: string, studyId: string, options?: AxiosRequestConfig) {
        return DonorApiFp(this.configuration).readUsingGET1(id, studyId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExportApi - axios parameter creator
 * @export
 */
export const ExportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Exports the payload for a list of analysisIds
         * @summary ExportAnalysis
         * @param {string} analysisIds Comma separated list of analysisIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportAnalysisUsingGET: async (analysisIds: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'analysisIds' is not null or undefined
            assertParamExists('exportAnalysisUsingGET', 'analysisIds', analysisIds)
            const localVarPath = `/export/analysis/{analysisIds}`
                .replace(`{${"analysisIds"}}`, encodeURIComponent(String(analysisIds)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exports all the payloads for a study
         * @summary ExportStudy
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportStudyUsingGET: async (studyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('exportStudyUsingGET', 'studyId', studyId)
            const localVarPath = `/export/studies/{studyId}`
                .replace(`{${"studyId"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExportApi - functional programming interface
 * @export
 */
export const ExportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExportApiAxiosParamCreator(configuration)
    return {
        /**
         * Exports the payload for a list of analysisIds
         * @summary ExportAnalysis
         * @param {string} analysisIds Comma separated list of analysisIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportAnalysisUsingGET(analysisIds: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExportedPayload>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportAnalysisUsingGET(analysisIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Exports all the payloads for a study
         * @summary ExportStudy
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportStudyUsingGET(studyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExportedPayload>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportStudyUsingGET(studyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExportApi - factory interface
 * @export
 */
export const ExportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExportApiFp(configuration)
    return {
        /**
         * Exports the payload for a list of analysisIds
         * @summary ExportAnalysis
         * @param {string} analysisIds Comma separated list of analysisIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportAnalysisUsingGET(analysisIds: string, options?: any): AxiosPromise<Array<ExportedPayload>> {
            return localVarFp.exportAnalysisUsingGET(analysisIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Exports all the payloads for a study
         * @summary ExportStudy
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportStudyUsingGET(studyId: string, options?: any): AxiosPromise<Array<ExportedPayload>> {
            return localVarFp.exportStudyUsingGET(studyId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExportApi - object-oriented interface
 * @export
 * @class ExportApi
 * @extends {BaseAPI}
 */
export class ExportApi extends BaseAPI {
    /**
     * Exports the payload for a list of analysisIds
     * @summary ExportAnalysis
     * @param {string} analysisIds Comma separated list of analysisIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public exportAnalysisUsingGET(analysisIds: string, options?: AxiosRequestConfig) {
        return ExportApiFp(this.configuration).exportAnalysisUsingGET(analysisIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exports all the payloads for a study
     * @summary ExportStudy
     * @param {string} studyId studyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public exportStudyUsingGET(studyId: string, options?: AxiosRequestConfig) {
        return ExportApiFp(this.configuration).exportStudyUsingGET(studyId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FileApi - axios parameter creator
 * @export
 */
export const FileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes file data for fileIds
         * @summary DeleteFiles
         * @param {string} ids Comma separated list of fileIds
         * @param {string} studyId studyId
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsingDELETE1: async (ids: string, studyId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteUsingDELETE1', 'ids', ids)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('deleteUsingDELETE1', 'studyId', studyId)
            const localVarPath = `/studies/{studyId}/files/{ids}`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids)))
                .replace(`{${"studyId"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves file data for a fileId
         * @summary ReadFile
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsingGET2: async (id: string, studyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readUsingGET2', 'id', id)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('readUsingGET2', 'studyId', studyId)
            const localVarPath = `/studies/{studyId}/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"studyId"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates file data for a fileId
         * @summary UpdateFile
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {FileUpdateRequest} fileUpdateRequest File data to update
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsingPUT: async (id: string, studyId: string, fileUpdateRequest: FileUpdateRequest, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUsingPUT', 'id', id)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('updateUsingPUT', 'studyId', studyId)
            // verify required parameter 'fileUpdateRequest' is not null or undefined
            assertParamExists('updateUsingPUT', 'fileUpdateRequest', fileUpdateRequest)
            const localVarPath = `/studies/{studyId}/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"studyId"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileApi - functional programming interface
 * @export
 */
export const FileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes file data for fileIds
         * @summary DeleteFiles
         * @param {string} ids Comma separated list of fileIds
         * @param {string} studyId studyId
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsingDELETE1(ids: string, studyId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUsingDELETE1(ids, studyId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves file data for a fileId
         * @summary ReadFile
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUsingGET2(id: string, studyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUsingGET2(id, studyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates file data for a fileId
         * @summary UpdateFile
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {FileUpdateRequest} fileUpdateRequest File data to update
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUsingPUT(id: string, studyId: string, fileUpdateRequest: FileUpdateRequest, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUsingPUT(id, studyId, fileUpdateRequest, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FileApi - factory interface
 * @export
 */
export const FileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileApiFp(configuration)
    return {
        /**
         * Deletes file data for fileIds
         * @summary DeleteFiles
         * @param {string} ids Comma separated list of fileIds
         * @param {string} studyId studyId
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsingDELETE1(ids: string, studyId: string, authorization?: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteUsingDELETE1(ids, studyId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves file data for a fileId
         * @summary ReadFile
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsingGET2(id: string, studyId: string, options?: any): AxiosPromise<FileEntity> {
            return localVarFp.readUsingGET2(id, studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates file data for a fileId
         * @summary UpdateFile
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {FileUpdateRequest} fileUpdateRequest File data to update
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsingPUT(id: string, studyId: string, fileUpdateRequest: FileUpdateRequest, authorization?: string, options?: any): AxiosPromise<FileUpdateResponse> {
            return localVarFp.updateUsingPUT(id, studyId, fileUpdateRequest, authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileApi - object-oriented interface
 * @export
 * @class FileApi
 * @extends {BaseAPI}
 */
export class FileApi extends BaseAPI {
    /**
     * Deletes file data for fileIds
     * @summary DeleteFiles
     * @param {string} ids Comma separated list of fileIds
     * @param {string} studyId studyId
     * @param {string} [authorization] Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public deleteUsingDELETE1(ids: string, studyId: string, authorization?: string, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).deleteUsingDELETE1(ids, studyId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves file data for a fileId
     * @summary ReadFile
     * @param {string} id id
     * @param {string} studyId studyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public readUsingGET2(id: string, studyId: string, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).readUsingGET2(id, studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates file data for a fileId
     * @summary UpdateFile
     * @param {string} id id
     * @param {string} studyId studyId
     * @param {FileUpdateRequest} fileUpdateRequest File data to update
     * @param {string} [authorization] Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public updateUsingPUT(id: string, studyId: string, fileUpdateRequest: FileUpdateRequest, authorization?: string, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).updateUsingPUT(id, studyId, fileUpdateRequest, authorization, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Checks if the server is running
         * @summary IsAlive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAliveUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/isAlive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * Checks if the server is running
         * @summary IsAlive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isAliveUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isAliveUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * Checks if the server is running
         * @summary IsAlive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAliveUsingGET(options?: any): AxiosPromise<boolean> {
            return localVarFp.isAliveUsingGET(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * Checks if the server is running
     * @summary IsAlive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public isAliveUsingGET(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).isAliveUsingGET(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LegacyEntityApi - axios parameter creator
 * @export
 */
export const LegacyEntityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Page through LegacyEntity data
         * @summary FindLegacyEntities
         * @param {string} [access] 
         * @param {any} [fields] fields
         * @param {string} [fileName] 
         * @param {string} [gnosId] 
         * @param {string} [id] 
         * @param {number} [offset] 
         * @param {number} [page] Results page you want to retrieve (0..N)
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {string} [projectCode] 
         * @param {number} [size] Number of records per page.
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsingGET: async (access?: string, fields?: any, fileName?: string, gnosId?: string, id?: string, offset?: number, page?: number, pageNumber?: number, pageSize?: number, paged?: boolean, projectCode?: string, size?: number, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/entities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (access !== undefined) {
                localVarQueryParameter['access'] = access;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (fileName !== undefined) {
                localVarQueryParameter['fileName'] = fileName;
            }

            if (gnosId !== undefined) {
                localVarQueryParameter['gnosId'] = gnosId;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (paged !== undefined) {
                localVarQueryParameter['paged'] = paged;
            }

            if (projectCode !== undefined) {
                localVarQueryParameter['projectCode'] = projectCode;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sortSorted !== undefined) {
                localVarQueryParameter['sort.sorted'] = sortSorted;
            }

            if (sortUnsorted !== undefined) {
                localVarQueryParameter['sort.unsorted'] = sortUnsorted;
            }

            if (unpaged !== undefined) {
                localVarQueryParameter['unpaged'] = unpaged;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read entity data for a legacy entity id
         * @summary ReadLegacyEntity
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsingGET3: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readUsingGET3', 'id', id)
            const localVarPath = `/entities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LegacyEntityApi - functional programming interface
 * @export
 */
export const LegacyEntityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LegacyEntityApiAxiosParamCreator(configuration)
    return {
        /**
         * Page through LegacyEntity data
         * @summary FindLegacyEntities
         * @param {string} [access] 
         * @param {any} [fields] fields
         * @param {string} [fileName] 
         * @param {string} [gnosId] 
         * @param {string} [id] 
         * @param {number} [offset] 
         * @param {number} [page] Results page you want to retrieve (0..N)
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {string} [projectCode] 
         * @param {number} [size] Number of records per page.
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUsingGET(access?: string, fields?: any, fileName?: string, gnosId?: string, id?: string, offset?: number, page?: number, pageNumber?: number, pageSize?: number, paged?: boolean, projectCode?: string, size?: number, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonNode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUsingGET(access, fields, fileName, gnosId, id, offset, page, pageNumber, pageSize, paged, projectCode, size, sortSorted, sortUnsorted, unpaged, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Read entity data for a legacy entity id
         * @summary ReadLegacyEntity
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUsingGET3(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Legacy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUsingGET3(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LegacyEntityApi - factory interface
 * @export
 */
export const LegacyEntityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LegacyEntityApiFp(configuration)
    return {
        /**
         * Page through LegacyEntity data
         * @summary FindLegacyEntities
         * @param {string} [access] 
         * @param {any} [fields] fields
         * @param {string} [fileName] 
         * @param {string} [gnosId] 
         * @param {string} [id] 
         * @param {number} [offset] 
         * @param {number} [page] Results page you want to retrieve (0..N)
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {string} [projectCode] 
         * @param {number} [size] Number of records per page.
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsingGET(access?: string, fields?: any, fileName?: string, gnosId?: string, id?: string, offset?: number, page?: number, pageNumber?: number, pageSize?: number, paged?: boolean, projectCode?: string, size?: number, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any): AxiosPromise<JsonNode> {
            return localVarFp.findUsingGET(access, fields, fileName, gnosId, id, offset, page, pageNumber, pageSize, paged, projectCode, size, sortSorted, sortUnsorted, unpaged, options).then((request) => request(axios, basePath));
        },
        /**
         * Read entity data for a legacy entity id
         * @summary ReadLegacyEntity
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsingGET3(id: string, options?: any): AxiosPromise<Legacy> {
            return localVarFp.readUsingGET3(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LegacyEntityApi - object-oriented interface
 * @export
 * @class LegacyEntityApi
 * @extends {BaseAPI}
 */
export class LegacyEntityApi extends BaseAPI {
    /**
     * Page through LegacyEntity data
     * @summary FindLegacyEntities
     * @param {string} [access] 
     * @param {any} [fields] fields
     * @param {string} [fileName] 
     * @param {string} [gnosId] 
     * @param {string} [id] 
     * @param {number} [offset] 
     * @param {number} [page] Results page you want to retrieve (0..N)
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {boolean} [paged] 
     * @param {string} [projectCode] 
     * @param {number} [size] Number of records per page.
     * @param {boolean} [sortSorted] 
     * @param {boolean} [sortUnsorted] 
     * @param {boolean} [unpaged] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LegacyEntityApi
     */
    public findUsingGET(access?: string, fields?: any, fileName?: string, gnosId?: string, id?: string, offset?: number, page?: number, pageNumber?: number, pageSize?: number, paged?: boolean, projectCode?: string, size?: number, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: AxiosRequestConfig) {
        return LegacyEntityApiFp(this.configuration).findUsingGET(access, fields, fileName, gnosId, id, offset, page, pageNumber, pageSize, paged, projectCode, size, sortSorted, sortUnsorted, unpaged, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read entity data for a legacy entity id
     * @summary ReadLegacyEntity
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LegacyEntityApi
     */
    public readUsingGET3(id: string, options?: AxiosRequestConfig) {
        return LegacyEntityApiFp(this.configuration).readUsingGET3(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SampleApi - axios parameter creator
 * @export
 */
export const SampleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes sample data for sampleIds
         * @summary DeleteSamples
         * @param {string} ids Comma separated list of sampleIds
         * @param {string} studyId studyId
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsingDELETE2: async (ids: string, studyId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteUsingDELETE2', 'ids', ids)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('deleteUsingDELETE2', 'studyId', studyId)
            const localVarPath = `/studies/{studyId}/samples/{ids}`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids)))
                .replace(`{${"studyId"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves sample data for a sampleId
         * @summary ReadSample
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsingGET4: async (id: string, studyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readUsingGET4', 'id', id)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('readUsingGET4', 'studyId', studyId)
            const localVarPath = `/studies/{studyId}/samples/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"studyId"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SampleApi - functional programming interface
 * @export
 */
export const SampleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SampleApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes sample data for sampleIds
         * @summary DeleteSamples
         * @param {string} ids Comma separated list of sampleIds
         * @param {string} studyId studyId
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsingDELETE2(ids: string, studyId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUsingDELETE2(ids, studyId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves sample data for a sampleId
         * @summary ReadSample
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUsingGET4(id: string, studyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sample>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUsingGET4(id, studyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SampleApi - factory interface
 * @export
 */
export const SampleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SampleApiFp(configuration)
    return {
        /**
         * Deletes sample data for sampleIds
         * @summary DeleteSamples
         * @param {string} ids Comma separated list of sampleIds
         * @param {string} studyId studyId
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsingDELETE2(ids: string, studyId: string, authorization?: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteUsingDELETE2(ids, studyId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves sample data for a sampleId
         * @summary ReadSample
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsingGET4(id: string, studyId: string, options?: any): AxiosPromise<Sample> {
            return localVarFp.readUsingGET4(id, studyId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SampleApi - object-oriented interface
 * @export
 * @class SampleApi
 * @extends {BaseAPI}
 */
export class SampleApi extends BaseAPI {
    /**
     * Deletes sample data for sampleIds
     * @summary DeleteSamples
     * @param {string} ids Comma separated list of sampleIds
     * @param {string} studyId studyId
     * @param {string} [authorization] Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SampleApi
     */
    public deleteUsingDELETE2(ids: string, studyId: string, authorization?: string, options?: AxiosRequestConfig) {
        return SampleApiFp(this.configuration).deleteUsingDELETE2(ids, studyId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves sample data for a sampleId
     * @summary ReadSample
     * @param {string} id id
     * @param {string} studyId studyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SampleApi
     */
    public readUsingGET4(id: string, studyId: string, options?: AxiosRequestConfig) {
        return SampleApiFp(this.configuration).readUsingGET4(id, studyId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SchemaApi - axios parameter creator
 * @export
 */
export const SchemaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the meta-schema used to validate AnalysisType schemas during registration
         * @summary GetRegistrationSchema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisTypeRegistrationSchemaUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/schemas/registration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the latest version of a schema for an analysisType
         * @summary GetAnalysisTypeVersion
         * @param {string} name The name of an analysisType
         * @param {boolean} [unrenderedOnly] Only retrieve the unrendered schema that was initially registered
         * @param {number} [version] Optionally, retrieve a specific version of the analysisType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisTypeVersionUsingGET: async (name: string, unrenderedOnly?: boolean, version?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getAnalysisTypeVersionUsingGET', 'name', name)
            const localVarPath = `/schemas/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (unrenderedOnly !== undefined) {
                localVarQueryParameter['unrenderedOnly'] = unrenderedOnly;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of registered analysisTypes
         * @summary ListAnalysisTypes
         * @param {boolean} [hideSchema] Hide the schema field from the response
         * @param {number} [limit] Number of results to retrieve
         * @param {Array<string>} [names] Comma separated list of names
         * @param {number} [offset] Index of first result to retrieve
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {string} [sort] Comma separated fields to sort on
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {boolean} [unpaged] 
         * @param {boolean} [unrenderedOnly] Only retrieve the unrendered schema that was initially registered
         * @param {Array<number>} [versions] Comma separated list of versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnalysisTypesUsingGET: async (hideSchema?: boolean, limit?: number, names?: Array<string>, offset?: number, pageNumber?: number, pageSize?: number, paged?: boolean, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, sortOrder?: string, unpaged?: boolean, unrenderedOnly?: boolean, versions?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/schemas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (hideSchema !== undefined) {
                localVarQueryParameter['hideSchema'] = hideSchema;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (names) {
                localVarQueryParameter['names'] = names;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (paged !== undefined) {
                localVarQueryParameter['paged'] = paged;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortSorted !== undefined) {
                localVarQueryParameter['sort.sorted'] = sortSorted;
            }

            if (sortUnsorted !== undefined) {
                localVarQueryParameter['sort.unsorted'] = sortUnsorted;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (unpaged !== undefined) {
                localVarQueryParameter['unpaged'] = unpaged;
            }

            if (unrenderedOnly !== undefined) {
                localVarQueryParameter['unrenderedOnly'] = unrenderedOnly;
            }

            if (versions) {
                localVarQueryParameter['versions'] = versions;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers an analysisType schema
         * @summary RegisterAnalysisType
         * @param {RegisterAnalysisTypeRequest} request request
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUsingPOST: async (request: RegisterAnalysisTypeRequest, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('registerUsingPOST', 'request', request)
            const localVarPath = `/schemas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemaApi - functional programming interface
 * @export
 */
export const SchemaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchemaApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the meta-schema used to validate AnalysisType schemas during registration
         * @summary GetRegistrationSchema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnalysisTypeRegistrationSchemaUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnalysisTypeRegistrationSchemaUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the latest version of a schema for an analysisType
         * @summary GetAnalysisTypeVersion
         * @param {string} name The name of an analysisType
         * @param {boolean} [unrenderedOnly] Only retrieve the unrendered schema that was initially registered
         * @param {number} [version] Optionally, retrieve a specific version of the analysisType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnalysisTypeVersionUsingGET(name: string, unrenderedOnly?: boolean, version?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysisType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnalysisTypeVersionUsingGET(name, unrenderedOnly, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of registered analysisTypes
         * @summary ListAnalysisTypes
         * @param {boolean} [hideSchema] Hide the schema field from the response
         * @param {number} [limit] Number of results to retrieve
         * @param {Array<string>} [names] Comma separated list of names
         * @param {number} [offset] Index of first result to retrieve
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {string} [sort] Comma separated fields to sort on
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {boolean} [unpaged] 
         * @param {boolean} [unrenderedOnly] Only retrieve the unrendered schema that was initially registered
         * @param {Array<number>} [versions] Comma separated list of versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAnalysisTypesUsingGET(hideSchema?: boolean, limit?: number, names?: Array<string>, offset?: number, pageNumber?: number, pageSize?: number, paged?: boolean, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, sortOrder?: string, unpaged?: boolean, unrenderedOnly?: boolean, versions?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDTOAnalysisType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAnalysisTypesUsingGET(hideSchema, limit, names, offset, pageNumber, pageSize, paged, sort, sortSorted, sortUnsorted, sortOrder, unpaged, unrenderedOnly, versions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Registers an analysisType schema
         * @summary RegisterAnalysisType
         * @param {RegisterAnalysisTypeRequest} request request
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUsingPOST(request: RegisterAnalysisTypeRequest, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysisType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUsingPOST(request, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SchemaApi - factory interface
 * @export
 */
export const SchemaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchemaApiFp(configuration)
    return {
        /**
         * Retrieves the meta-schema used to validate AnalysisType schemas during registration
         * @summary GetRegistrationSchema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisTypeRegistrationSchemaUsingGET(options?: any): AxiosPromise<string> {
            return localVarFp.getAnalysisTypeRegistrationSchemaUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the latest version of a schema for an analysisType
         * @summary GetAnalysisTypeVersion
         * @param {string} name The name of an analysisType
         * @param {boolean} [unrenderedOnly] Only retrieve the unrendered schema that was initially registered
         * @param {number} [version] Optionally, retrieve a specific version of the analysisType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisTypeVersionUsingGET(name: string, unrenderedOnly?: boolean, version?: number, options?: any): AxiosPromise<AnalysisType> {
            return localVarFp.getAnalysisTypeVersionUsingGET(name, unrenderedOnly, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of registered analysisTypes
         * @summary ListAnalysisTypes
         * @param {boolean} [hideSchema] Hide the schema field from the response
         * @param {number} [limit] Number of results to retrieve
         * @param {Array<string>} [names] Comma separated list of names
         * @param {number} [offset] Index of first result to retrieve
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {string} [sort] Comma separated fields to sort on
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
         * @param {boolean} [unpaged] 
         * @param {boolean} [unrenderedOnly] Only retrieve the unrendered schema that was initially registered
         * @param {Array<number>} [versions] Comma separated list of versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnalysisTypesUsingGET(hideSchema?: boolean, limit?: number, names?: Array<string>, offset?: number, pageNumber?: number, pageSize?: number, paged?: boolean, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, sortOrder?: string, unpaged?: boolean, unrenderedOnly?: boolean, versions?: Array<number>, options?: any): AxiosPromise<PageDTOAnalysisType> {
            return localVarFp.listAnalysisTypesUsingGET(hideSchema, limit, names, offset, pageNumber, pageSize, paged, sort, sortSorted, sortUnsorted, sortOrder, unpaged, unrenderedOnly, versions, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers an analysisType schema
         * @summary RegisterAnalysisType
         * @param {RegisterAnalysisTypeRequest} request request
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUsingPOST(request: RegisterAnalysisTypeRequest, authorization?: string, options?: any): AxiosPromise<AnalysisType> {
            return localVarFp.registerUsingPOST(request, authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchemaApi - object-oriented interface
 * @export
 * @class SchemaApi
 * @extends {BaseAPI}
 */
export class SchemaApi extends BaseAPI {
    /**
     * Retrieves the meta-schema used to validate AnalysisType schemas during registration
     * @summary GetRegistrationSchema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public getAnalysisTypeRegistrationSchemaUsingGET(options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).getAnalysisTypeRegistrationSchemaUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the latest version of a schema for an analysisType
     * @summary GetAnalysisTypeVersion
     * @param {string} name The name of an analysisType
     * @param {boolean} [unrenderedOnly] Only retrieve the unrendered schema that was initially registered
     * @param {number} [version] Optionally, retrieve a specific version of the analysisType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public getAnalysisTypeVersionUsingGET(name: string, unrenderedOnly?: boolean, version?: number, options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).getAnalysisTypeVersionUsingGET(name, unrenderedOnly, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of registered analysisTypes
     * @summary ListAnalysisTypes
     * @param {boolean} [hideSchema] Hide the schema field from the response
     * @param {number} [limit] Number of results to retrieve
     * @param {Array<string>} [names] Comma separated list of names
     * @param {number} [offset] Index of first result to retrieve
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {boolean} [paged] 
     * @param {string} [sort] Comma separated fields to sort on
     * @param {boolean} [sortSorted] 
     * @param {boolean} [sortUnsorted] 
     * @param {string} [sortOrder] Sorting order: ASC|DESC. Default order: DESC
     * @param {boolean} [unpaged] 
     * @param {boolean} [unrenderedOnly] Only retrieve the unrendered schema that was initially registered
     * @param {Array<number>} [versions] Comma separated list of versions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public listAnalysisTypesUsingGET(hideSchema?: boolean, limit?: number, names?: Array<string>, offset?: number, pageNumber?: number, pageSize?: number, paged?: boolean, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, sortOrder?: string, unpaged?: boolean, unrenderedOnly?: boolean, versions?: Array<number>, options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).listAnalysisTypesUsingGET(hideSchema, limit, names, offset, pageNumber, pageSize, paged, sort, sortSorted, sortUnsorted, sortOrder, unpaged, unrenderedOnly, versions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers an analysisType schema
     * @summary RegisterAnalysisType
     * @param {RegisterAnalysisTypeRequest} request request
     * @param {string} [authorization] Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public registerUsingPOST(request: RegisterAnalysisTypeRequest, authorization?: string, options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).registerUsingPOST(request, authorization, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SpecimenApi - axios parameter creator
 * @export
 */
export const SpecimenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes specimen data and all dependent samples for specimenIds
         * @summary DeleteSpecimens
         * @param {string} ids Comma separated list of specimenIds
         * @param {string} studyId studyId
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsingDELETE3: async (ids: string, studyId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteUsingDELETE3', 'ids', ids)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('deleteUsingDELETE3', 'studyId', studyId)
            const localVarPath = `/studies/{studyId}/specimens/{ids}`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids)))
                .replace(`{${"studyId"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves specimen data for a specimenId
         * @summary ReadSpecimen
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsingGET5: async (id: string, studyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readUsingGET5', 'id', id)
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('readUsingGET5', 'studyId', studyId)
            const localVarPath = `/studies/{studyId}/specimens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"studyId"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpecimenApi - functional programming interface
 * @export
 */
export const SpecimenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SpecimenApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes specimen data and all dependent samples for specimenIds
         * @summary DeleteSpecimens
         * @param {string} ids Comma separated list of specimenIds
         * @param {string} studyId studyId
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsingDELETE3(ids: string, studyId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUsingDELETE3(ids, studyId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves specimen data for a specimenId
         * @summary ReadSpecimen
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUsingGET5(id: string, studyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Specimen>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUsingGET5(id, studyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SpecimenApi - factory interface
 * @export
 */
export const SpecimenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SpecimenApiFp(configuration)
    return {
        /**
         * Deletes specimen data and all dependent samples for specimenIds
         * @summary DeleteSpecimens
         * @param {string} ids Comma separated list of specimenIds
         * @param {string} studyId studyId
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsingDELETE3(ids: string, studyId: string, authorization?: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteUsingDELETE3(ids, studyId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves specimen data for a specimenId
         * @summary ReadSpecimen
         * @param {string} id id
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsingGET5(id: string, studyId: string, options?: any): AxiosPromise<Specimen> {
            return localVarFp.readUsingGET5(id, studyId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SpecimenApi - object-oriented interface
 * @export
 * @class SpecimenApi
 * @extends {BaseAPI}
 */
export class SpecimenApi extends BaseAPI {
    /**
     * Deletes specimen data and all dependent samples for specimenIds
     * @summary DeleteSpecimens
     * @param {string} ids Comma separated list of specimenIds
     * @param {string} studyId studyId
     * @param {string} [authorization] Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpecimenApi
     */
    public deleteUsingDELETE3(ids: string, studyId: string, authorization?: string, options?: AxiosRequestConfig) {
        return SpecimenApiFp(this.configuration).deleteUsingDELETE3(ids, studyId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves specimen data for a specimenId
     * @summary ReadSpecimen
     * @param {string} id id
     * @param {string} studyId studyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpecimenApi
     */
    public readUsingGET5(id: string, studyId: string, options?: AxiosRequestConfig) {
        return SpecimenApiFp(this.configuration).readUsingGET5(id, studyId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StudyApi - axios parameter creator
 * @export
 */
export const StudyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves all studyIds
         * @summary GetAllStudyIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllStudiesUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/studies/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all donor, specimen and sample data for a study
         * @summary GetEntireStudy
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntireStudyUsingGET: async (studyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('getEntireStudyUsingGET', 'studyId', studyId)
            const localVarPath = `/studies/{studyId}/all`
                .replace(`{${"studyId"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves information for a study
         * @summary GetStudy
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyUsingGET: async (studyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('getStudyUsingGET', 'studyId', studyId)
            const localVarPath = `/studies/{studyId}`
                .replace(`{${"studyId"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new study
         * @summary CreateStudy
         * @param {string} studyId studyId
         * @param {Study} study study
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveStudyUsingPOST: async (studyId: string, study: Study, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('saveStudyUsingPOST', 'studyId', studyId)
            // verify required parameter 'study' is not null or undefined
            assertParamExists('saveStudyUsingPOST', 'study', study)
            const localVarPath = `/studies/{studyId}/`
                .replace(`{${"studyId"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(study, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudyApi - functional programming interface
 * @export
 */
export const StudyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudyApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves all studyIds
         * @summary GetAllStudyIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllStudiesUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllStudiesUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves all donor, specimen and sample data for a study
         * @summary GetEntireStudy
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntireStudyUsingGET(studyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudyWithDonors>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntireStudyUsingGET(studyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves information for a study
         * @summary GetStudy
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudyUsingGET(studyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Study>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudyUsingGET(studyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new study
         * @summary CreateStudy
         * @param {string} studyId studyId
         * @param {Study} study study
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveStudyUsingPOST(studyId: string, study: Study, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveStudyUsingPOST(studyId, study, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StudyApi - factory interface
 * @export
 */
export const StudyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudyApiFp(configuration)
    return {
        /**
         * Retrieves all studyIds
         * @summary GetAllStudyIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllStudiesUsingGET(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.findAllStudiesUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all donor, specimen and sample data for a study
         * @summary GetEntireStudy
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntireStudyUsingGET(studyId: string, options?: any): AxiosPromise<StudyWithDonors> {
            return localVarFp.getEntireStudyUsingGET(studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves information for a study
         * @summary GetStudy
         * @param {string} studyId studyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyUsingGET(studyId: string, options?: any): AxiosPromise<Study> {
            return localVarFp.getStudyUsingGET(studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new study
         * @summary CreateStudy
         * @param {string} studyId studyId
         * @param {Study} study study
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveStudyUsingPOST(studyId: string, study: Study, authorization?: string, options?: any): AxiosPromise<GenericMessage> {
            return localVarFp.saveStudyUsingPOST(studyId, study, authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudyApi - object-oriented interface
 * @export
 * @class StudyApi
 * @extends {BaseAPI}
 */
export class StudyApi extends BaseAPI {
    /**
     * Retrieves all studyIds
     * @summary GetAllStudyIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyApi
     */
    public findAllStudiesUsingGET(options?: AxiosRequestConfig) {
        return StudyApiFp(this.configuration).findAllStudiesUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all donor, specimen and sample data for a study
     * @summary GetEntireStudy
     * @param {string} studyId studyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyApi
     */
    public getEntireStudyUsingGET(studyId: string, options?: AxiosRequestConfig) {
        return StudyApiFp(this.configuration).getEntireStudyUsingGET(studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves information for a study
     * @summary GetStudy
     * @param {string} studyId studyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyApi
     */
    public getStudyUsingGET(studyId: string, options?: AxiosRequestConfig) {
        return StudyApiFp(this.configuration).getStudyUsingGET(studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new study
     * @summary CreateStudy
     * @param {string} studyId studyId
     * @param {Study} study study
     * @param {string} [authorization] Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyApi
     */
    public saveStudyUsingPOST(studyId: string, study: Study, authorization?: string, options?: AxiosRequestConfig) {
        return StudyApiFp(this.configuration).saveStudyUsingPOST(studyId, study, authorization, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubmitApi - axios parameter creator
 * @export
 */
export const SubmitApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Synchronously submit a json payload
         * @summary Submit
         * @param {string} studyId studyId
         * @param {string} jsonPayload json_payload
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitUsingPOST: async (studyId: string, jsonPayload: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('submitUsingPOST', 'studyId', studyId)
            // verify required parameter 'jsonPayload' is not null or undefined
            assertParamExists('submitUsingPOST', 'jsonPayload', jsonPayload)
            const localVarPath = `/submit/{studyId}`
                .replace(`{${"studyId"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubmitApi - functional programming interface
 * @export
 */
export const SubmitApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubmitApiAxiosParamCreator(configuration)
    return {
        /**
         * Synchronously submit a json payload
         * @summary Submit
         * @param {string} studyId studyId
         * @param {string} jsonPayload json_payload
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitUsingPOST(studyId: string, jsonPayload: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmitResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitUsingPOST(studyId, jsonPayload, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubmitApi - factory interface
 * @export
 */
export const SubmitApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubmitApiFp(configuration)
    return {
        /**
         * Synchronously submit a json payload
         * @summary Submit
         * @param {string} studyId studyId
         * @param {string} jsonPayload json_payload
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitUsingPOST(studyId: string, jsonPayload: string, authorization?: string, options?: any): AxiosPromise<SubmitResponse> {
            return localVarFp.submitUsingPOST(studyId, jsonPayload, authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubmitApi - object-oriented interface
 * @export
 * @class SubmitApi
 * @extends {BaseAPI}
 */
export class SubmitApi extends BaseAPI {
    /**
     * Synchronously submit a json payload
     * @summary Submit
     * @param {string} studyId studyId
     * @param {string} jsonPayload json_payload
     * @param {string} [authorization] Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmitApi
     */
    public submitUsingPOST(studyId: string, jsonPayload: string, authorization?: string, options?: AxiosRequestConfig) {
        return SubmitApiFp(this.configuration).submitUsingPOST(studyId, jsonPayload, authorization, options).then((request) => request(this.axios, this.basePath));
    }
}


